<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>perl11 blog</title>
    <link>http://perl11.org/blog/index.xml</link>
    <description>Recent content on perl11 blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© 2016 Copyright Reini Urban</copyright>
    <lastBuildDate>Mon, 22 Oct 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://perl11.org/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Link-time and post-link optimizations</title>
      <link>http://perl11.org/blog/bolt.html</link>
      <pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/bolt.html</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve tried several traditional linker optimizations on cperl recently.
The easiest is&lt;/p&gt;

&lt;h1 id=&#34;lto&#34;&gt;LTO&lt;/h1&gt;

&lt;p&gt;via &lt;code&gt;gcc -flto=4&lt;/code&gt; or &lt;code&gt;clang -flto=thin&lt;/code&gt;. This requires the gold linker, and
enables multi-threaded link-time optimizations.&lt;/p&gt;

&lt;p&gt;For gcc my configure script does&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CC=${CC:-ccache gcc}
./Configure -sder -Dcc=&amp;quot;$CC&amp;quot; \
  -Dld=&amp;quot;$CC -fuse-linker-plugin&amp;quot; \
  -Accflags=&amp;quot;-flto=4 -fuse-ld=gold -msse4.2 -march=native&amp;quot; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and for clang&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CC=${CC:-ccache clang-7}
./Configure -sder -Dcc=&amp;quot;$CC&amp;quot; \
  -Dranlib=llvm-ranlib-7 -Dar=llvm-ar-7 -Dfull_ar=/usr/bin/llvm-ar-7 \
  -Accflags=&amp;quot;-DLTO -flto=thin -msse4.2 -march=native&amp;quot; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The impact is about 10%.&lt;/p&gt;

&lt;h1 id=&#34;autofdo&#34;&gt;AutoFDO&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://gcc.gnu.org/wiki/AutoFDO&#34;&gt;AutoFDO&lt;/a&gt; is the optimized profile guided optimization
method on linux via perf, in opposite to &lt;code&gt;-pg&lt;/code&gt; without &lt;code&gt;perf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On most recent kernels you need to recompile &lt;a href=&#34;https://github.com/google/autofdo&#34;&gt;autofdo&lt;/a&gt; by yourself&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone --recursive https://github.com/google/autofdo
cd autofdo
aclocal -I .; autoheader; autoconf; automake --add-missing -c
./configure --with-llvm=/usr/bin/llvm-config-7
make -s
make -s install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The perl/cperl Makefile already contains two targets for gcc: &lt;code&gt;miniperl.autofdo&lt;/code&gt;
and &lt;code&gt;perl.autofdo&lt;/code&gt;. For clang just replace &lt;code&gt;create_gcov&lt;/code&gt; with &lt;code&gt;create_llvm_gcov&lt;/code&gt;.
The &lt;code&gt;perl.autofdo&lt;/code&gt; target just optimizes a static &lt;code&gt;perl&lt;/code&gt; executable, not the shared
&lt;code&gt;libperl.so&lt;/code&gt;, so beware. miniperl is always static, so you can measure the impact there easier.
For me it&amp;rsquo;s about 20%.&lt;/p&gt;

&lt;p&gt;The old method was the profile-guided optimization as described in the
gcc manual, also with a gcov file.&lt;/p&gt;

&lt;h1 id=&#34;bolt&#34;&gt;BOLT&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebookincubator/BOLT&#34;&gt;llvm-bolt&lt;/a&gt; is a bit similar to &lt;a href=&#34;https://community.linuxmint.com/tutorial/view/473&#34;&gt;prelink&lt;/a&gt;
from libreoffice. It&amp;rsquo;s a post-link optimizer.
It analyzes perf traces from a running executable or service, and then rewrites the binary
to be faster.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve compiled bolt at &lt;code&gt;/usr/src/llvm/llvm-bolt/build&lt;/code&gt;, added the bin path to my PATH
&lt;code&gt;export PATH=/usr/src/llvm/llvm-bolt/build/bin:$PATH&lt;/code&gt;, added the &lt;code&gt;-Wl,-q&lt;/code&gt; flag to ldflags
and lddlflags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -i -e&amp;quot;s,ldflags=&#39;,ldflags=&#39;-Wl,-q ,&amp;quot; config.sh
sed -i -e&amp;quot;s,lddlflags=&#39;,lddlflags=&#39;-Wl,-q ,&amp;quot; config.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before: &lt;code&gt;perf stat -r2 ./minibench.sh&lt;/code&gt;, where &lt;code&gt;minibench.sh&lt;/code&gt; is the script created by &lt;code&gt;miniperl.autofdo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Using bolt:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perf record -e cycles:u -j any,u -o bolt.data -- ./minibench.sh
perf2bolt -p bolt.data -o bolt.fdata miniperl
llvm-bolt miniperl -o miniperl.bolt -data=bolt.fdata -reorder-blocks=cache+ 
  -reorder-functions=hfsort+ -split-functions=3 -split-all-cold -split-eh -dyno-stats
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BOLT-INFO: Target architecture: x86_64
BOLT-INFO: first alloc address is 0x400000
BOLT-INFO: creating new program header table at address 0x800000, offset 0x400000
BOLT-INFO: enabling relocation mode
BOLT-INFO: 640 functions out of 1602 simple functions (40.0%) have non-empty execution profile.
BOLT-INFO: 60 non-simple function(s) have profile.
BOLT-INFO: profile for 1 objects was ignored
BOLT-INFO: the input contains 702 (dynamic count : 1471) missed opportunities for macro-fusion
           optimization. Will fix instances on a hot path.
BOLT-INFO: removed 2 &#39;repz&#39; prefixes with estimated execution count of 0 times.
BOLT-INFO: basic block reordering modified layout of 589 (32.05%) functions
BOLT-INFO: UCE removed 0 blocks and 0 bytes of code.
BOLT-INFO: running hfsort+ for 642 functions
BOLT-INFO: program-wide dynostats after all optimizations before SCTC and FOP:

          195150 : executed forward branches
           74347 : taken forward branches
           30966 : executed backward branches
           20082 : taken backward branches
           29596 : executed unconditional branches
           32611 : all function calls
            9659 : indirect calls
            5177 : PLT calls
         1501423 : executed instructions
          401528 : executed load instructions
          235761 : executed store instructions
            7071 : taken jump table branches
          255712 : total branches
          124025 : taken branches
          131687 : non-taken conditional branches
           94429 : taken conditional branches
          226116 : all conditional branches

          185751 : executed forward branches (-4.8%)
           13694 : taken forward branches (-81.6%)
           40365 : executed backward branches (+30.4%)
           20453 : taken backward branches (+1.8%)
           10158 : executed unconditional branches (-65.7%)
           32611 : all function calls (=)
            9659 : indirect calls (=)
            5177 : PLT calls (=)
         1478793 : executed instructions (-1.5%)
          401528 : executed load instructions (=)
          235761 : executed store instructions (=)
            7071 : taken jump table branches (=)
          236274 : total branches (-7.6%)
           44305 : taken branches (-64.3%)
          191969 : non-taken conditional branches (+45.8%)
           34147 : taken conditional branches (-63.8%)
          226116 : all conditional branches (=)

BOLT-INFO: SCTC: patched 27 tail calls (27 forward)
tail calls (0 backward) from a total of 27 while removing 0 double jumps and removing
14 basic blocks totalling 70 bytes of code. CTCs total execution count is 2 and the
number of times CTCs are taken is 0.
BOLT-INFO: setting _end to 0xe040b8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After: &lt;code&gt;perf stat -r2 ./minibench.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;=&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# before bolt
# started on Mon Oct 22 17:53:16 2018


 Performance counter stats for &#39;./minibench.sh&#39; (2 runs):

   3538.885152      task-clock (msec)         #    0.777 CPUs utilized            ( +-  0.07% )
         2,024      context-switches          #    0.572 K/sec                    ( +-  0.47% )
           301      cpu-migrations            #    0.085 K/sec                    ( +-  5.65% )
       278,208      page-faults               #    0.079 M/sec                    ( +-  0.00% )
10,721,866,060      cycles                    #    3.030 GHz                      ( +-  0.06% )
 5,875,656,960      stalled-cycles-frontend   #   54.80% frontend cycles idle     ( +-  0.10% )
 4,442,046,984      stalled-cycles-backend    #   41.43% backend cycles idle      ( +-  0.09% )
10,623,986,253      instructions              #    0.99  insn per cycle         
                                              #    0.55  stalled cycles per insn  ( +-  0.00% )
 2,225,877,429      branches                  #  628.977 M/sec                    ( +-  0.00% )
    86,592,270      branch-misses             #    3.89% of all branches          ( +-  0.07% )

       4.55333 +- 0.00405 seconds time elapsed  ( +-  0.09% )

# after bolt
# started on Mon Oct 22 17:55:46 2018

Performance counter stats for &#39;./minibench.sh&#39; (2 runs):

   3167.229126      task-clock (msec)         #    0.757 CPUs utilized            ( +-  0.12% )
         2,006      context-switches          #    0.633 K/sec                    ( +-  0.42% )
           293      cpu-migrations            #    0.093 K/sec                    ( +-  3.75% )
       279,450      page-faults               #    0.088 M/sec                    ( +-  0.03% )
 9,566,795,439      cycles                    #    3.021 GHz                      ( +-  0.00% )
 4,770,308,584      stalled-cycles-frontend   #   49.86% frontend cycles idle     ( +-  0.04% )
 3,558,581,947      stalled-cycles-backend    #   37.20% backend cycles idle      ( +-  0.01% )
10,580,856,372      instructions              #    1.11  insn per cycle         
                                              #    0.45  stalled cycles per insn  ( +-  0.03% )
 2,143,510,267      branches                  #  676.778 M/sec                    ( +-  0.04% )
    92,102,204      branch-misses             #    4.30% of all branches          ( +-  0.06% )

       4.18226 +- 0.00375 seconds time elapsed  ( +-  0.09% )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is an impact of 9% on the already link-time optimized executable. Nice!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;prelink&lt;/code&gt; would also gain a lot of startup overhead, but is a bit
fragile, as every system update on any shared library would break it.&lt;/p&gt;

&lt;h1 id=&#34;static-linker-optimizations&#34;&gt;Static linker optimizations&lt;/h1&gt;

&lt;p&gt;Now you ask how to get all the linker optimizations into the source
code and build-environment, to avoid all these compiler and linker
optimizations.&lt;/p&gt;

&lt;p&gt;The first problem is to add missing or wrong &lt;code&gt;LIKELY&lt;/code&gt;/&lt;code&gt;UNLIKELY&lt;/code&gt; hints
to the branches in the sources.  I&amp;rsquo;m not aware of any automatic tool
yet, which can display the location of the data or gcov file of a
branch-hit or miss. But the source code is pretty good annotated
already. perf itself gives a few hints in its UI.&lt;/p&gt;

&lt;p&gt;The next problem is how to get the LTO optimizations into the
Makefiles. We don&amp;rsquo;t need a linker script, re-arranging the order of
the objects or just appending all sources into one big C file and
compile only this would accomplish this. perl is a bit large, the
compiler would consume too much memory, so I went for the optimization
of the objects at first.&lt;/p&gt;

&lt;p&gt;There are two problem: permutate the objects itself, and second
rearrange the functions inside the objects.  Measuring all
permutations of the 38 objects would need several years, perl cannot
even represent the number as 64bit integer for a loop counter. So I&amp;rsquo;ve
tried a guided search on most permutations, from back to forth, and
stop subsequent permutations at the back when the generated file is slower
than before.  Something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @o = glob &amp;lt;*.o&amp;gt;;
my $best;
compile(\@o);
my $curr = bench($i);
$best = $curr;
my $p = $#o;
for my $i (0..5000) {
  $p = permute(\@o, $p, $curr);
};

sub permute {
  my ($a,$p,$curr) = @_;
  my @idx = 0..$#{$a};
  my $new = $curr;
  while ($new &amp;lt;= $curr) { # faster?
    $curr = $new;
    --$p while $idx[$p-1] &amp;gt; $idx[$p];
    my $q = $p or return $p;
    push @idx, reverse splice @idx, $p;
    ++$q while $idx[$p-1] &amp;gt; $idx[$q];
    @idx[$p-1,$q] = @idx[$q,$p-1];
    my $tmp = $a-&amp;gt;[$p-1];
    $a-&amp;gt;[$p-1] = $a-&amp;gt;[$q];
    $a-&amp;gt;[$q] = $tmp;

    compile($a);
    $new = bench($i);
    print &amp;quot;# &amp;quot;,join(&amp;quot; &amp;quot;,map{substr($_,0,-2)} @$a),&amp;quot;\n&amp;quot;;
  }
  $p
}

sub compile {
  my @o = @{$_[0]};
  if ($^O eq &#39;linux&#39;) {
    system(&amp;quot;gcc -fstack-protector -L/usr/local/lib -L/opt/local/lib &amp;quot;.
           &amp;quot;-o miniperl @o -lpthread -lnsl -ldl -lm -lcrypt -lutil -lc&amp;quot;);
  } elsif ($^O eq &#39;darwin&#39;) {
    system(&amp;quot;cc -mmacosx-version-min=10.11 -fstack-protector -L/usr/local/lib &amp;quot;.
           &amp;quot;-L/opt/local/lib -force_flat_namespace -o miniperl @o -lpthread -ldl -lm -lutil -lc&amp;quot;);
  }
}

sub bench {
  my ($i) = @_;
  system(&amp;quot;./miniperl t/opbasic/arith.t &amp;gt;/dev/null 2&amp;gt;/dev/null&amp;quot;); # warmup
  my $t0 = [gettimeofday];
  system(&amp;quot;./minibench.sh&amp;quot;);
  my $elapsed = tv_interval ( $t0 );
  print &amp;quot;$i $elapsed\n&amp;quot;;
  if ($elapsed &amp;lt; $best) {
    $best = $elapsed;
    print &amp;quot;# RECORD:\n&amp;quot;;
  }
  $elapsed
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This revealed that the current object layout is suboptimal, several
miniperl-specific objects need to be spliced into the common_objs.&lt;/p&gt;

&lt;p&gt;The best order on linux was:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gv | perlmini miniperlmain | perly toke | opmini | av pad sv hv pp_hot run
pp_ctl pp_type | ppmini | scope pp_sys regcomp mg doop util doio keywords
| xsutilsmini | utf8 regexec universal perlapi globals perlio pp_sort pp_pack
numeric reentr mathoms locale dquote mro_core taint time64 caretx dump deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The old order was:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;miniperlmain opmini perlmini xsutilsmini ppmini |
gv toke perly pad regcomp dump util mg reentr mro_core keywords
hv av run pp_hot sv pp_type scope pp_ctl pp_sys
doop doio regexec utf8 taint deb universal globals perlio perlapi
numeric mathoms locale pp_pack pp_sort caretx dquote time64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You see the pattern: The earliest and most important objects start at
first, gv being the slowest and mostly used part, then the startup,
the parser, the compiler, the data, then the run-time and at last the
helpers.  Nearby functions are called faster, static relative offsets
can be shorter.  Note that cperl seperated xsutils and pp also into
&lt;em&gt;mini&lt;/em&gt; parts because of the FFI.&lt;/p&gt;

&lt;p&gt;The performance of the various orders varied wildly: from 3.031298s
to 3.990619s, i.e. +-31%.
See &lt;a href=&#34;https://gist.github.com/rurban/67cb4b4046a3538837b6c2aade18ba2f&#34;&gt;https://gist.github.com/rurban/67cb4b4046a3538837b6c2aade18ba2f&lt;/a&gt; for the
script and result log.&lt;/p&gt;

&lt;p&gt;Relevant are also the size of the environment for a proper stack
alignment, we cannot control that. It&amp;rsquo;s over the 2% noise rate though.
&amp;ldquo;Producing Wrong Data Without Doing Anything Obviously Wrong!&amp;rdquo;
&lt;a href=&#34;https://www.seas.upenn.edu/~cis501/papers/producing-wrong-data.pdf&#34;&gt;https://www.seas.upenn.edu/~cis501/papers/producing-wrong-data.pdf&lt;/a&gt; has more
info about that. It also discusses why sometimes -O2 was faster than -O3.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/&#34;&gt;/r/cperl&lt;/a&gt;.&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Removal of the perl4 &#39; package seperator</title>
      <link>http://perl11.org/blog/quote-identifiers.html</link>
      <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/quote-identifiers.html</guid>
      <description>

&lt;p&gt;The removal of the old and deprecated perl4 single quote character &lt;code&gt;&#39;&lt;/code&gt;
as valid package seperator in cperl went through various steps.
It&amp;rsquo;s also explained in &lt;a href=&#34;http://perl11.org/cperl/perldata.html#Identifier-parsing&#34;&gt;perldata&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are still two package separators in perl5:&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;double colon&lt;/strong&gt; (&lt;code&gt;::&lt;/code&gt;) and a &lt;strong&gt;single quote&lt;/strong&gt; (&lt;code&gt;&#39;&lt;/code&gt;).  Normal
identifiers can start or end with a double colon, and can contain
several parts delimited by double colons.  Single quotes within &lt;strong&gt;perl5&lt;/strong&gt;
have similar rules, but with the exception that they are not legal at
the end of an identifier: That is, &lt;code&gt;$&#39;foo&lt;/code&gt; and &lt;code&gt;$foo&#39;bar&lt;/code&gt; are legal,
but &lt;code&gt;$foo&#39;bar&#39;&lt;/code&gt; is not.&lt;/p&gt;

&lt;p&gt;In &lt;strong&gt;cperl&lt;/strong&gt; only the double colon (&lt;code&gt;::&lt;/code&gt;) is a legal package
separator, the perl4 package seperator &lt;code&gt;&#39;&lt;/code&gt; was made illegal with
5.26c, and since 5.28c is now legal part of the identifer.  Full
support for the single quote &lt;code&gt;&#39;&lt;/code&gt; as part of an identifer came with
5.28c, and matches now the behavior of perl6.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub isn&#39;t { } # parsed as isn&#39;t since 5.28c, illegal with 5.26c,
              # before parsed as isn::t
isn&#39;t()       # parsed as isn&#39;t since 5.28c, illegal with 5.26c,
              # before parsed as isn::t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Differences and caveats, when being expanded in strings:&lt;/p&gt;

&lt;p&gt;Note that hashes are not expanded, e.g. &lt;code&gt;&amp;quot;%file&#39;s&amp;quot;&lt;/code&gt; stays &lt;code&gt;&amp;quot;%file&#39;s&amp;quot;&lt;/code&gt;,
only scalars and arrays are expanded.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $file = &amp;quot;test&amp;quot;;
my @file = (&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;);
if ($^O !~ /c$/ or $] &amp;lt; 5.026) { # pre 5.26c
  is(&amp;quot;$file&#39;s test&amp;quot;, &amp;quot; test&amp;quot;);   # parsed as file::s
  is(&amp;quot;@file&#39;s test&amp;quot;, &amp;quot; test&amp;quot;);
}
elsif ($^O =~ /c$/ and $] &amp;gt;= 5.026 and $] &amp;lt; 5.028) { # 5.26c
  is(&amp;quot;$file&#39;s test&amp;quot;, &amp;quot;test&#39;s test&amp;quot;); # parsed as $file . &amp;quot;&#39;s test&amp;quot;
  is(&amp;quot;@file&#39;s test&amp;quot;, &amp;quot;a b&#39;s test&amp;quot;);
}
elsif ($^O =~ /c$/ and $] &amp;gt;= 5.028) { # 5.28c
  is(&amp;quot;$file&#39;s test&amp;quot;, &amp;quot; test&amp;quot;);   # parsed as $file&#39;s. &amp;quot; test&amp;quot;
  is(&amp;quot;@file&#39;s test&amp;quot;, &amp;quot; test&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;perl6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;no strict;
my $file = &amp;quot;test&amp;quot;;
my @file = &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;;
is(&amp;quot;$file&#39;s test&amp;quot;, &amp;quot; test&amp;quot;);        # parsed as $file&#39;s. &amp;quot; test&amp;quot;
is(&amp;quot;@file&#39;s test&amp;quot;, &amp;quot;@file&#39;s test&amp;quot;); # @ is not expanded anymore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s no plan to follow the perl6 syntax decision to not expand the
&lt;code&gt;@&lt;/code&gt; sigil in strings anymore. This is a fundamental perl5 feature and
widely (ab)used for various cases, which cannot be changed. We also
don&amp;rsquo;t find that breaking change useful.&lt;/p&gt;

&lt;p&gt;Additionally, if the identifier is preceded by a sigil -
that is, if the identifier is part of a variable name - it
may optionally be enclosed in braces.&lt;/p&gt;

&lt;p&gt;So to properly expand such a scalar string without the quote you
need to use &lt;code&gt;&amp;quot;${file}&#39;s&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  is(&amp;quot;${file}&#39;s test&amp;quot;, &amp;quot;test&#39;s test&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It worked for a short time in 5.26c without the &lt;code&gt;{}&lt;/code&gt; quoting, but only
in this particular version.&lt;/p&gt;

&lt;p&gt;There are still some modules on CPAN which rely on the wrong outdated
perl4 behaviour. Mostly test related modules which insist on using &lt;code&gt;isn&#39;t&lt;/code&gt;
as a method name. There&amp;rsquo;s nothing wrong in using &lt;code&gt;isn&#39;t&lt;/code&gt; as name, just
beware that it is not expanded to &lt;code&gt;isn::t&lt;/code&gt; anymore. I.e. it&amp;rsquo;s in the
main module namespace, and not a method called &lt;code&gt;&amp;quot;t&amp;quot;&lt;/code&gt; in the &lt;code&gt;&amp;quot;isn&amp;quot;&lt;/code&gt; sub
namespace. It&amp;rsquo;s also illegal with 5.26c and cannot be parsed.&lt;/p&gt;

&lt;p&gt;For XS modules there&amp;rsquo;s the &lt;code&gt;PERL_NO_QUOTE_PKGSEPERATOR&lt;/code&gt; definition.
It is defined in cperl since 5.26c. Affected are only &lt;code&gt;Sub::Name&lt;/code&gt; and
&lt;code&gt;Sub::Util&lt;/code&gt;. &lt;code&gt;Sub::Name&lt;/code&gt; is broken for a long time and should not be used,
and &lt;code&gt;Sub::Util&lt;/code&gt; is distributed in cperl and perl5 core.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-9niw89-removal-of-the-perl4-package-seperator&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/9niw89/removal_of_the_perl4_package_seperator/&#34;&gt;/r/cperl&lt;/a&gt;.&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>There be getcwd dragons</title>
      <link>http://perl11.org/blog/fastcwd.html</link>
      <pubDate>Thu, 11 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/fastcwd.html</guid>
      <description>

&lt;p&gt;The Cwd perl5 module contains various functions to return the string
of the current working directory.  The POSIX API only contains
&lt;code&gt;getcwd()&lt;/code&gt;, some provide also &lt;code&gt;getwd()&lt;/code&gt; - ignored in perl, and the
glibc also provides &lt;code&gt;get_current_dir_name()&lt;/code&gt; and supports a NULL
argument for &lt;code&gt;getcwd(char *buf, size_t size)&lt;/code&gt;.  The Cwd module adds
cwd, getcwd, getdcwd for Windows with a drive letter, fastcwd,
fastgetcwd.&lt;/p&gt;

&lt;h1 id=&#34;symlinks&#34;&gt;symlinks&lt;/h1&gt;

&lt;p&gt;The simplify the explanation of the various variants, which in theory
should all return the same string, consider symlinks. If &lt;code&gt;realpath
&amp;quot;.&amp;quot;&lt;/code&gt; expands to something else than your &lt;code&gt;$PWD&lt;/code&gt;, then the current
directory is behind a symlink. This is a big problem for &lt;code&gt;rmtree&lt;/code&gt;, as
chdir&amp;rsquo;ing into a directory which is a symlink would lead to a
situation, where you cannot step out to the previous directory again,
and rmtree would continue deleting something else.  You might chdir
out of a directory that you can&amp;rsquo;t chdir back into.&lt;/p&gt;

&lt;p&gt;So to summarize the fastcwd variants, they could return a directory
which contains a symlink, while getcwd should always resolve all
symlinks.  In practice fastcwd should be usable for most cases and
does return the logically correct directory, so users are not surprised
by returning different pathnames for the same directory. But when you
traverse a tree, resolving symlinks should be done to avoid troubles.&lt;/p&gt;

&lt;p&gt;cwd() is normally implemented as fastcwd(), just very slow.  E.g. by
shelling out to &lt;code&gt;pwd&lt;/code&gt;. You really should never use &lt;strong&gt;cwd&lt;/strong&gt;, only &lt;strong&gt;fastcwd&lt;/strong&gt;
or &lt;strong&gt;getcwd&lt;/strong&gt;, depending on your use case.&lt;/p&gt;

&lt;h1 id=&#34;long-pathnames&#34;&gt;long pathnames&lt;/h1&gt;

&lt;p&gt;On POSIX system the maximal length of a path is specified with
&lt;code&gt;_POSIX_PATH_MAX&lt;/code&gt; or &lt;code&gt;PATH_MAX&lt;/code&gt;, which is usually 4096. Older systems
have sometimes limits like 256, newer systems like Windows NT via
certain APIs like 32K. But the actual limitation is really based on
the filesystem, see &lt;a href=&#34;https://eklitzke.org/path-max-is-tricky&#34;&gt;https://eklitzke.org/path-max-is-tricky&lt;/a&gt;.  Many
filesystems do support much longer pathnames than just 4096.  On POSIX
you could use &lt;code&gt;pathconf&lt;/code&gt; to get the actual limit for this mountpoint,
or you could do it like in cperl: Use the correct API
(&lt;code&gt;get_current_dir_name&lt;/code&gt;, &lt;code&gt;getcwd(NULL, 0)&lt;/code&gt;), or check with growing
path buffers until &lt;code&gt;ENAMETOOLONG&lt;/code&gt; is not returned anymore.&lt;/p&gt;

&lt;p&gt;In cperl all the Cwd functions can handle overlong pathnames for some years
already, perl5 cannot.&lt;/p&gt;

&lt;h1 id=&#34;security&#34;&gt;security&lt;/h1&gt;

&lt;p&gt;Attacks on bugs and limitations on pathname API&amp;rsquo;s are quite common and
easy to use. With the right symlink in user space or overlong pathnames
you can trick the system into race attacks.
See e.g. &lt;a href=&#34;http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=487319&#34;&gt;http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=487319&lt;/a&gt; or
&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2017-6512&#34;&gt;https://nvd.nist.gov/vuln/detail/CVE-2017-6512&lt;/a&gt; on the File::Path module, which
creates paths and removes trees.&lt;/p&gt;

&lt;p&gt;When your system getcwd function does not resolve symlinks, i.e. it is
just fastcwd, rmtree is still vulnerable to symlink attacks. E.g. as
outlined in &lt;a href=&#34;https://github.com/jkeenan/File-Path/pull/7&#34;&gt;https://github.com/jkeenan/File-Path/pull/7&lt;/a&gt;, which the
maintainer is unwilling to fix.  Also note that the File::Path API
became a mess recently. On yet unsupported arguments, like uid, group
or owner on Windows, the latest version dies, the previous versions
returned an error. As if Windows would not support such metadata. In
fact Windows support much more metadata than traditional POSIX
filesystems, such as ACLs.&lt;/p&gt;

&lt;p&gt;This fastcwd problem can e.g. be seen with CPAN, when &lt;code&gt;~/.cpan/build&lt;/code&gt;
resolves to something else.  Then the &lt;code&gt;tmp-$$&lt;/code&gt; directory cannot be
deleted, and CPAN aborts.  Or with DBD::File, when your virtual tables
are returned with a &amp;ldquo;./&amp;rdquo; prefix when using fastcwd and not getcwd.&lt;/p&gt;

&lt;p&gt;But there are so many security problems in perl5, that you really should not
use perl5 in production with public access. Only cperl, which does have those
kind of bugs fixed. And many more.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-9n86il-there-be-getcwd-dragons&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/9n86il/there_be_getcwd_dragons/&#34;&gt;/r/cperl&lt;/a&gt;.&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>cperl classes</title>
      <link>http://perl11.org/blog/cperl-classes.html</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/cperl-classes.html</guid>
      <description>

&lt;h1 id=&#34;subtitle-why-a-mop-is-not-always-a-good-idea&#34;&gt;Subtitle: &lt;em&gt;Why a MOP is not always a good idea&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;cperl being a perl11, i.e. 5+6=11, of course means that cperl classes
are designed after perl5 and perl6 classes. perl5 does not have a
builtin &lt;strong&gt;class&lt;/strong&gt; keyword, but allows to add keywords to be added at
runtime. cperl and perl6 of course do have a builtin class keyword.&lt;/p&gt;

&lt;p&gt;The backcompat problem with a new builtin keyword is, that some usages
of variables, package or function names will not work anymore, because
the new keyword stepped over it. With the current cperl 5.28 release
this is indeed a problem for the existing &lt;code&gt;B::class&lt;/code&gt; method which
cannot be imported anymore and be used as &lt;code&gt;class($op)&lt;/code&gt;. Instead all
these usage have been replaced with &lt;code&gt;B::class($op)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Technically this can be avoided by hijacking only the first token
in a statement, and let those be valid cperl terms:
&lt;code&gt;$class&lt;/code&gt;, &lt;code&gt;sub class {}&lt;/code&gt;, &lt;code&gt;package class;&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;an-example&#34;&gt;An example&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;class Test::Builder::Module {
    has int $Child_Error;
    has $Parent;
    has $Parent_TODO;
    has str $Name;
    has str $Child_Name;
    has Bailed_Out_Reason;
    has Bailed_Out;
    has bool $Have_Plan;
    has $No_Plan;
    has $Skip_All;
    has @Test_Results;
}

class Test::More is Test::Builder::Module {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just look at the
&lt;a href=&#34;https://docs.perl6.org/language/classtut&#34;&gt;Perl6 Class Tutorial&lt;/a&gt; and
replace all &amp;ldquo;traits&amp;rdquo; behind signatures with attributes.&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;method area() returns Int {}&lt;/code&gt; =&amp;gt; &lt;code&gt;method area() :Int {}&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;p&gt;&lt;code&gt;has Bool $.done is rw;&lt;/code&gt; =&amp;gt; &lt;code&gt;has Bool $done :rw;&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;leave out the new secondory sigils,
e.g.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;has Int $.x;&lt;/code&gt; =&amp;gt; &lt;code&gt;has Int $x;&lt;/code&gt;, and you got the cperl syntax.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Point {
    has Int $x;
    has Int $y;
}

class Rectangle {
    has Point $lower;
    has Point $upper;

    method area() :Int {
        ($upper-&amp;gt;x - $lower-&amp;gt;x) * ( $upper-&amp;gt;y - $lower-&amp;gt;y);
    }
}

# Create a new Rectangle from two Points
my $r = new Rectangle(lower =&amp;gt; new Point(x =&amp;gt; 0, y =&amp;gt; 0),
                      upper =&amp;gt; new Point(x =&amp;gt; 10, y =&amp;gt; 10));
say $r-&amp;gt;area; # OUTPUT: Â«100â¤Â» 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The old perl5 design for this was:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Point; use fields qw(x y);
sub new {
    my str $name = shift;
    bless {@_}, $name;
}

package Rectangle;
use base (&#39;Point&#39;); use fields qw(lower upper);
sub new {
    my str $name = shift;
    bless {@_}, $name;
}
sub area {
    my Rectangle $self = shift;
    my ($lower, $upper) = ($self-&amp;gt;{lower}, $self-&amp;gt;{upper});
    ($upper-&amp;gt;{x} - $lower-&amp;gt;{x}) * ($upper-&amp;gt;{y} - $lower-&amp;gt;{y});
}
my $r = new Rectangle(lower =&amp;gt; new Point(x =&amp;gt; 0, y =&amp;gt; 0),
                      upper =&amp;gt; new Point(x =&amp;gt; 10, y =&amp;gt; 10));
print $r-&amp;gt;area; # OUTPUT: Â«100Â» 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the old pre-5.10 pseudo-hashes the field names &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;lower&lt;/code&gt;
as hash keys where compile-time optimized to linear-time array access
to the magic &lt;code&gt;@Rectangle::FIELDS&lt;/code&gt; array.  The hash was made restricted,
ensuring typos in the field names would lead to compile-time errors
when those keys did not exist.&lt;/p&gt;

&lt;p&gt;With perl6 or cperl fields you&amp;rsquo;ve got the same feature; just a
different, more functional implementation. &amp;ldquo;functional&amp;rdquo; meaning
features are hidden between functions, not datatypes. Supporting
datatypes in an API will forever restrict it&amp;rsquo;s usage to this specific
datatype, you will not be able to change the underlying structures and
algorithms. This was the biggest mistakes perl and python did at the beginning.&lt;/p&gt;

&lt;h1 id=&#34;encapsulated-fields&#34;&gt;Encapsulated fields&lt;/h1&gt;

&lt;p&gt;In perl6 fields are encapsulated. &lt;em&gt;&amp;ldquo;Just as a my variable cannot be
accessed from outside its declared scope, fields are not accessible
outside of the class. This encapsulation is one of the key principles
of object oriented design.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;perl5 fields were optionally private if given a &lt;code&gt;_&lt;/code&gt; prefix, but you
could always use the magic &lt;code&gt;@FIELDS&lt;/code&gt; array and hash in the first slot
to access the private fields also.&lt;/p&gt;

&lt;p&gt;cperl fields are encapsulated, but the trait syntax is different to
perl6.  You should use the method syntax, not a hash or array access
syntax. Internally this method is then compiled to the most efficient
op or method.&lt;/p&gt;

&lt;p&gt;The Moose syntax is more different to perl6 than cperl. And it&amp;rsquo;s
implemention is beyond naive. But theoretically this could be
improved, the biggest problem is still the troublesome syntax, based
on the naive implementation restrictions.&lt;/p&gt;

&lt;p&gt;With the new cperl fields API you can inspect all defined fields at
run-time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# return-value of Mu::fields or classobj-&amp;gt;fields
class Foo {
    has $foo;
    has @bar;
    has %baz :const;
}
my @fields = Foo-&amp;gt;fields;
print $fields[0]-&amp;gt;name; # foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With cperl classes the fields methods returns a list of fields
objects, representing the has declarations of the class with all
imported roles - similar to the perl6
&lt;a href=&#34;https://docs.perl6.org/type/Metamodel::ClassHOW#(Metamodel::AttributeContainer)_method_attributes|Metamodel::AttributeContainer&#34;&gt;Metamodel::AttributeContainer&lt;/a&gt;
returning &lt;a href=&#34;https://docs.perl6.org/type/Attribute|Attribute&#34;&gt;Attribute&lt;/a&gt; objects.&lt;/p&gt;

&lt;p&gt;Each such returned field object supports the following methods &lt;code&gt;name&lt;/code&gt;,
&lt;code&gt;package&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;get_value&lt;/code&gt; and &lt;code&gt;set_value&lt;/code&gt;.  The fields
method is valid for classes and objects. Only objects do have values,
therefore &lt;code&gt;{g,s}et_value&lt;/code&gt; on a class field is invalid.&lt;/p&gt;

&lt;h1 id=&#34;types-oo&#34;&gt;Types, OO&lt;/h1&gt;

&lt;p&gt;There are type systems and there are type systems.  Nominal or
structural, co variant/contra variant, sound or unsound, making it
slower or making it faster, static or dynamic, gradual or optional,
hated or beloved.&lt;/p&gt;

&lt;p&gt;What almost nobody knows, perl5 always had room for types built-in.
&lt;code&gt;my Coffee $c;&lt;/code&gt; assigned the type &lt;code&gt;Coffee&lt;/code&gt; to the scalar variable &lt;code&gt;$c&lt;/code&gt; at
compile-time. The type &lt;code&gt;Coffee&lt;/code&gt; needed to exist already, i.e. it needed
to be a properly declared package. Internally every package (or &amp;ldquo;class&amp;rdquo;)
defines a global symbol-table names space, a hash of symbols under main.
i.e. &lt;code&gt;%main::Coffee::&lt;/code&gt; (called a stash, &amp;ldquo;symboltable hash&amp;rdquo;).
There are even some modules on CPAN which declares types on some of its
variables.
&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Types are compile-time guarantees and hints for the compiler and optimizer.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Types structure classes and method dispatch.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Types document code, makes code stricter, with more static guarantees.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can gradually switch from obsessive test driven development with
test suites running hours with over-architectured refactoring,
to obsessive statically typed code, running in 2x faster time,
and not being able to debug into compile-time errors,
which were previously dynamic run-time errors.&lt;/p&gt;

&lt;p&gt;This concept came with Common Lisp and its famously optimizing
compiler, called &lt;a href=&#34;http://www.sbcl.org/manual/#Handling-of-Types&#34;&gt;python&lt;/a&gt;.
Yes, really, the CMUCL compiler, now still alive as SBCL. Types and compiler
pragmas were purely optional, as every symbol and variable carried its
type with itself.  &lt;code&gt;(or (&amp;gt;= safety 2) (&amp;gt;= safety speed 1))&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defmacro my-1+ (x)
    `(the fixnum (1+ (the fixnum ,x))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Statically typed variables loose all of its types at run-time - if you
strip it from its dwarf sections, but nobody does run-time type
introspection via dwarf besides
&lt;a href=&#34;https://www.cl.cam.ac.uk/~srk31/&#34;&gt;Stephen Kell&lt;/a&gt;, just via horrible
C++ RTTI.&lt;/p&gt;

&lt;p&gt;Object systems are basically classes, i.e. types, declared with fields
and methods. The optimizer figures out the object layout according to
the type hierarchy, the fields and methods.&lt;/p&gt;

&lt;h1 id=&#34;mop&#34;&gt;MOP&lt;/h1&gt;

&lt;p&gt;A MOP (&amp;ldquo;meta object protocol&amp;rdquo;) was invented to change the default
behavior for objects, methods and classes, basically to make them
better and slower.  It came up with the differences in LISP frames vs
CLOS. In CL we had a huge slow monster CLOS, and many small elegant but
limited &amp;ldquo;frames&amp;rdquo; systems.&lt;/p&gt;

&lt;p&gt;Now we know basically three types of object systems:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;classic hierarchical compile-time classes with inheritance,
shared methods per class (C++),&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dynamic prototypes with all the methods in the objects (javascript),&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mixins with compile-time composition of classes, in
contrast to run-time dispatch to parents via inheritance (flavors,
CLOS, ruby include).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With a MOP you are even able to change a classic system to a prototype or mixin
system, and vice versa.
Ruby on rails (ab)used the MOP all over which makes it imposible to scale.
With a proper OO design as in Sinatra/Dancer with delegated classes known at
compile-time you can easily scale and optimize such a system. A MOP is a very
poor adhoc method to workaround a proper OO design. It&amp;rsquo;s nice for prototypes,
such as Moose, which is a very immature adhoc prototype, but it should never
make it into a production system.&lt;/p&gt;

&lt;h1 id=&#34;difference-from-class-to-package&#34;&gt;Difference from class to package&lt;/h1&gt;

&lt;p&gt;A cperl class is internally a readonly package with a CLASS flag set.
A class is closed, a readonly block by default. methods and fields are
fixed. If you want dynamic classes use a package. Fields are lexical
members of the class, copied into objects. Fields and methods can be
composed from roles, i.e. copied at compile-time. Conflicts are then
detected at compile-time, and not at run-time as with dynamic packages
and the ISA inheritance mechanism.&lt;/p&gt;

&lt;p&gt;Class fields have no variable data layout as with old blessed objects,
where fields could be stored as scalar, array or hash. Class fields
are stored as offset into a not-refcounted array, similar to C structs.
In fact with a the &lt;code&gt;:native&lt;/code&gt; attribute class objects can be passed via
the FFI to C back and forth. An int field takes 4 byte, a double field 8 byte,
and not 4 words as a normal scalar value.&lt;/p&gt;

&lt;h1 id=&#34;anon-classes&#34;&gt;Anon classes&lt;/h1&gt;

&lt;p&gt;Intermediate classes create via role mixins (the &lt;code&gt;does&lt;/code&gt; keyword) are
stored in the class slot of every object and refer to class stashes.
But when you mix types or multiple classes combined via &lt;code&gt;and&lt;/code&gt; or
&lt;code&gt;or&lt;/code&gt; you cannot use a stash, you&amp;rsquo;d need a list of stashes.&lt;/p&gt;

&lt;p&gt;perl6 solved this problem by switching from stashes to objects.
perl5 solved this via creating temporary anon classes to hold mixins, and
&lt;code&gt;mro&lt;/code&gt;/&lt;code&gt;@ISA&lt;/code&gt; to support multiple inheritance.&lt;/p&gt;

&lt;p&gt;cperl composes mixins at compile-time, without the need to hold anon
classes at all.&lt;/p&gt;

&lt;h1 id=&#34;multiple-dispatch-polymorphism&#34;&gt;Multiple dispatch - polymorphism&lt;/h1&gt;

&lt;p&gt;cperl 5.28 does not support the &lt;strong&gt;multi&lt;/strong&gt; keyword yet, there&amp;rsquo;s no
polymorph dispatch on methods with the same name (generics) but
varying number and type of arguments yet. polymorphism solves the problem of
generic methods, which do the same but its implemention deviates on the given
arguments. E.g. &lt;code&gt;+&lt;/code&gt; acts differently on double or int or string.
polymorphism is the proper solution for problems previously solved with
the &lt;strong&gt;overload&lt;/strong&gt; pragma.&lt;/p&gt;

&lt;p&gt;Internally multi methods will be stored with a name suffix, either
seperated by the public name with &lt;code&gt;\0&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt;, followed by the types
of the accepted arguments.  The signature is encoded into the name. This
is similar to C++ name mangling for the run-time dispatcher.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\0&lt;/code&gt; is a good prefix because in cperl binary names are forbidden, for
security and performance reasons.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@&lt;/code&gt; would be a good prefix because cperl adopted &lt;code&gt;@&lt;/code&gt; from
Devel:::NYTProf for names of anonymous subroutines. An &amp;ldquo;&lt;strong&gt;ANON&lt;/strong&gt;&amp;ldquo;
import method in cperl is named &amp;ldquo;import@&amp;rdquo; instead, in Devel:::NYTProf
it would be even named &amp;ldquo;import@[package.pm,10-12]&amp;ldquo;.  perl5 anonymizes some
names when the GV symbol is being thrown away to &lt;code&gt;__ANON__&lt;/code&gt;, esp. with
import methods.&lt;/p&gt;

&lt;h1 id=&#34;limitations&#34;&gt;Limitations&lt;/h1&gt;

&lt;p&gt;5.28 still has some class &lt;a href=&#34;http://perl11.org/cperl/perlclass.html#LIMITATIONS&#34;&gt;limitations&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The number of fields is limited, as in C.&lt;/p&gt;

&lt;p&gt;The inliner is not yet implemented, so field index fixups with roles are not supported yet.
When copying a method from a role to a class, and the field index from the role method would
be different to a field index in the resulting class, the method is not yet fixed up to the
new indices. A temp. solution would be to change the ordering of the roles, or to use the
&lt;code&gt;$self-&amp;gt;field&lt;/code&gt; method syntax in the role method. This requires the not yet finished inliner.
Currently we can only alias composed role methods and we don&amp;rsquo;t change the ordering of the fields.&lt;/p&gt;

&lt;p&gt;eval &amp;lsquo;class {}&amp;rsquo; fails&lt;/p&gt;

&lt;p&gt;A class cannot be created in an eval block or subroutine. The pad lookup is still global and
not per optional CvPADLIST. During development of cperl 5.28 I found the
&lt;a href=&#34;https://github.com/perl11/cperl/issues/354&#34;&gt;severe limitations&lt;/a&gt; of the perl5 pad design,
the delegation of FAKE pads into nested scopes.
upvalues are not copied or delegated to the real slot in the outer pad, but just marked as NULL FAKE pad.
This led to severe compiler bugs, only fixed in 5.28.&lt;/p&gt;

&lt;p&gt;i.e.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @a[1];
sub { $a[1] = 1 }-&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;missed the compile-time error inside the closed-over sub.
Also all uoob (compile-time out-of-bounds checks) optimizations were missing on those nested fake PADs.
So I had to add a new pad API &lt;code&gt;pad_findmy_real&lt;/code&gt; to find the real pad/type of a nested lexical variable.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-9evcew-cperl-classes&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/9evcew/cperl_classes/&#34;&gt;/r/cperl&lt;/a&gt;.&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>safeclib-3.3 and its new compile-time checks</title>
      <link>http://perl11.org/blog/safeclib-3.3.html</link>
      <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/safeclib-3.3.html</guid>
      <description>

&lt;p&gt;In the previous
&lt;a href=&#34;foldcase.html&#34;&gt;&amp;ldquo;The sad state of foldcase and string comparisons&amp;rdquo;&lt;/a&gt;
article I already mentioned my safeclib library improvements, for the
surpringly rather unique ability to search for strings (with Unicode
support).&lt;/p&gt;

&lt;p&gt;With the recent
&lt;a href=&#34;https://github.com/rurban/safeclib/releases/tag/v03032018&#34;&gt;safeclib-3.3&lt;/a&gt;
release I made the almost same improvements as in cperl: Adding lots
of compile-time checks and seperating them out of the run-time. Do less
branching at run-time when the compiler can already prove that a
certain branch or check was already done at compile-time. With cperl
it is much easier, because there I can control both, the compiler and
the run-time. All in one exectable.&lt;/p&gt;

&lt;p&gt;With safeclib, the user just includes safeclib via
&lt;code&gt;#include &amp;quot;safe_lib.h&amp;quot;&lt;/code&gt; and compiles and links it with his own compiler.
There&amp;rsquo;s it&amp;rsquo;s much harder. Both clang and gcc do support such compile-time
checks via &lt;code&gt;__builtin_object_size&lt;/code&gt; (aka &lt;strong&gt;BOS&lt;/strong&gt;) and the ill-designed
&lt;code&gt;__builtin_choose_expr&lt;/code&gt;, and clang-5+ can now even throw user-defined
compile-time errors via &lt;code&gt;__attribute__((diagnose_if))&lt;/code&gt;, which is
extremely powerful and heavily used with safeclib-3.3.  All checks
which were previously done at run-time, to check for NULL pointers,
empty sizes, wrong size arguments for pointer sizes, overflows,
pointer overlaps and wrong constant values are now done at
compile-time with clang-5+. With a proper development environment,
e.g. emacs with flycheck or flymake with a check-syntax target in your
Makefile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# emacs flymake-mode
check-syntax:
    test -n &amp;quot;$(CHK_SOURCES)&amp;quot; &amp;amp;&amp;amp; \
      $(COMPILE) -o /dev/null -S $(CHK_SOURCES)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every wrong argument to a safeclib function is already warned about in
your IDE. &lt;img src=&#34;images/flymake-safec.png&#34;&gt;
On every keypress flymake runs the compiler on your C source via the
&lt;code&gt;make check-syntax CHK_SOURCES=&amp;quot;your-c-source.c&amp;quot;&lt;/code&gt; makefile target, and then
displays warnings in blue and errors in red, with the message as mouse-over
hover.&lt;/p&gt;

&lt;p&gt;strcat_s is defined in &lt;code&gt;safe_str_lib.h&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXTERN errno_t
_strcat_s_chk(char * restrict dest, rsize_t dmax, const char * restrict src,
              const size_t destbos)
    BOS_CHK(dest) BOS_NULL(src);
#define strcat_s(dest,dmax,src) _strcat_s_chk(dest,dmax,src,BOS(dest))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the new compile-time checks &lt;code&gt;BOS_CHK(dest)&lt;/code&gt; and &lt;code&gt;BOS_NULL(src)&lt;/code&gt; are defined in &lt;code&gt;safe_compile.h&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define BOS_CHK(dest)                                                 \
  __attribute__((diagnose_if(_BOS_OVR(dest,dmax), &amp;quot;dest overflow&amp;quot;, &amp;quot;error&amp;quot;))) \
  __attribute__((diagnose_if(_BOS_NULL(dest), &amp;quot;empty dest&amp;quot;, &amp;quot;error&amp;quot;))) \
  __attribute__((diagnose_if(_BOS_ZERO(dest,dmax), &amp;quot;empty dest or dmax&amp;quot;, &amp;quot;error&amp;quot;)))

#define BOS_NULL(dest)                                                  \
  __attribute__((diagnose_if(_BOS_NULL(dest), &amp;quot;empty dest&amp;quot;, &amp;quot;error&amp;quot;)))

#define _BOS_OVR(dest,dmax)    (_BOS_KNOWN(dest) &amp;amp;&amp;amp; (size_t)(dmax) &amp;gt; BOS(dest))
#define _BOS_ZERO(dest,dmax)   ((_BOS_KNOWN(dest) &amp;amp;&amp;amp; BOS(dest) == 0) || (dmax) == 0)
#define _BOS_NULL(dest)        ((_BOS_KNOWN(dest) &amp;amp;&amp;amp; BOS(dest) == 0) || !(dest))

#define BOS(dest)  __builtin_object_size((dest),1)
#define _BOS_KNOWN(dest)  ((size_t)BOS(dest) != BOS_UNKNOWN)
#define BOS_UNKNOWN ((size_t)-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So whenever a string, dest, is known to have a constant size, and the
size dmax is known to be constant at constant-folding time in the
compiler, BOS will not return BOS_UNKNOWN and the check expression
will be reduced to a constant integer, and a warning or error can be thrown.&lt;/p&gt;

&lt;h1 id=&#34;todo-static-assert-constexpr&#34;&gt;TODO static_assert/constexpr&lt;/h1&gt;

&lt;p&gt;With other compilers it&amp;rsquo;s not that easy. Almost all other compilers do
have BOS support for such constant-folding checks. But gcc will throw
an error if any argument to a compile-time expression is unknown/not a
constant, &lt;code&gt;constant_p&lt;/code&gt; does not help for non-pointers and BOS is not
known for &lt;code&gt;choose_expr&lt;/code&gt; so it cannot be used.  Also
&lt;code&gt;static_assert&lt;/code&gt; is only a statement and not an expression. &lt;code&gt;constexpr&lt;/code&gt; is
only available to g++, not gcc.&lt;/p&gt;

&lt;p&gt;You can write your own &lt;code&gt;static_assert&lt;/code&gt; as expression, the linux kernel
has such tricks.&lt;/p&gt;

&lt;p&gt;E.g. you can define &lt;code&gt;memcpy_s&lt;/code&gt; as such for gcc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* gcc bug: BOS is not a valid constant compile-time expression for gcc-7 */
#define memcpy_s(dest,dmax,src,slen)               \
    IFCONSTP(dmax, dmax != 0,                       \
      IFCONSTP(dmax, dmax &amp;lt; RSIZE_MAX_STR,          \
        IFCONSTP(dest, dest != NULL,                \
          IFCONSTP(src, src != NULL,                \
            _memcpy_s_chk(dest,dmax,src,slen,BOS(dest),BOS(src)), \
            &amp;quot;src is null&amp;quot;),                         \
          &amp;quot;dest is null&amp;quot;),                          \
        &amp;quot;dmax &amp;gt; max&amp;quot;),                              \
      &amp;quot;dmax is zero&amp;quot;)

#define CONSTP(ptr) __builtin_constant_p(ptr)
#define CHOOSE_EXPR(exp,ok,notok)    __builtin_choose_expr(exp,ok,notok)
#define IFCONSTP(var,exp,ok,errmsg) \
  CHOOSE_EXPR(CONSTP(var) ? (exp) : 1, (ok), &amp;quot;&amp;quot;errmsg[-1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;&amp;quot;errmsg[-1]&lt;/code&gt; will expand to &lt;code&gt;&amp;quot;src is null&amp;quot;[-1]&lt;/code&gt; which be an illegal
array access, and a compiler error error will be thrown with a useful
error message. This &lt;code&gt;memcpy_s()&lt;/code&gt; can be used within expressions, within
comma-lists unlike &lt;code&gt;static_assert&lt;/code&gt;.  But the problem is that some
expressions in this nested check, like &lt;code&gt;dmax &amp;gt; BOS(dest)&lt;/code&gt; (&amp;ldquo;dest
overflow&amp;rdquo;) will be invalid if the BOS is unknown.  The BOS for dest is
only known for stack allocation and direct malloc using system malloc
with &lt;code&gt;alloc_size&lt;/code&gt; support, and if the variable is not passed into longer
functions with insufficient compiler optimization levels, without
proper var-tracking. So that the compiler cannot prove the size of a
certain symbol, only its type.&lt;/p&gt;

&lt;p&gt;So only some errors can be detected with gcc at compile-time, not all
run-time checks can be performed at compile-time, and as such the
run-time has to suffer from a ~10% performance degradation.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also Intel&amp;rsquo;s MPX &lt;strong&gt;Pointer Bounds Checker&lt;/strong&gt; using special
registers and a hardware hash table for each pointer to hold the size
of an array, to be able to do fast run-time bounds checks. &lt;code&gt;icc&lt;/code&gt; has
this since icc-15, gcc since 5. In gcc performant only since 5.3. But
it is optional, not shipped with your packagers gcc. safeclib does
throw such mpx violations if supported, but in practice it&amp;rsquo;s very
rarely supported. BOS checks are much more common and successful,
esp. with clang-5+.&lt;/p&gt;

&lt;p&gt;The linux kernel compiletime assertions do look this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef HAVE_STATIC_ASSERT
# define __compiletime_assert(condition,msg,prefix,suffix) \
    static_assert(condition,msg);
#else
/* linux kernel a-like compile checks */
# if __has_attribute(error)
#  define __compiletime_error(msg) __attribute__((error(msg)))
#  define __compiletime_error_fallback(cond,msg) do { } while (0)
# else
#  define __compiletime_error(msg)
#  define __compiletime_error_fallback(cond,msg)                         \
         do { ((void)sizeof(char[1 - 2 * cond])); } while (0)
# endif
# define __compiletime_assert(condition, msg, prefix, suffix)           \
    do {                                                                \
        bool __cond = !(condition);                                     \
        extern void prefix ## suffix(void) __compiletime_error(msg);    \
        if (__cond) {                                                   \
            prefix ## suffix();                                         \
        }                                                               \
        __compiletime_error_fallback(__cond, msg);                      \
    } while (0)
#endif
#define _compiletime_assert(condition, msg, prefix, suffix)             \
        __compiletime_assert(condition, msg, prefix, suffix)
#define compiletime_assert(condition, msg)                              \
        _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and its usage would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define CT_DEST_NULL(ptr) \
    ({compiletime_assert(ptr != NULL, #ptr &amp;quot; is null&amp;quot;)},ptr)
#define CT_DMAX_ZERO(var)\
    ({compiletime_assert(var != 0, #var &amp;quot; is zero&amp;quot;)},var)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of &lt;code&gt;__LINE__&lt;/code&gt; as unique suffix, &lt;code&gt;__COUNTER__&lt;/code&gt; would be better,
esp. inside expressions, which can have multiple such asserts in a
single line. e.g. a function call. The unique suffix is needed for the
empty function with an &lt;code&gt;__attribute((error))&lt;/code&gt; attribute to throw the
user-defined error, similar to clang&amp;rsquo;s diagnose_if.
The &lt;code&gt;(void)sizeof(char[1 - 2 * cond]&lt;/code&gt; bit throws the compile-time error
if &lt;code&gt;cond&lt;/code&gt; is false and returns the value if &lt;code&gt;cond&lt;/code&gt; is true.&lt;/p&gt;

&lt;p&gt;The kernel has dirty thinks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define CT_DEST_NULL(ptr) ((void *)sizeof(struct { int:-!!(ptr); }))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with &lt;code&gt;!!(ptr)&lt;/code&gt; collapsing the pointer value to a boolean to 0 or 1,
with -1 being the invalid bitfield size, leading to the compile-time
error. But this is hardly portable, and anon structs are not valid with
&lt;code&gt;-pedantic&lt;/code&gt;, which is used for safeclib.&lt;/p&gt;

&lt;p&gt;So why not using static_assert statement checks?&lt;/p&gt;

&lt;p&gt;This depends on the compiler ability to track the size of variables
across function boundaries. We can only add the &lt;code&gt;static_assert&lt;/code&gt; at the beginning
of the body of our functions, e.g. &lt;code&gt;strcat_s&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXPORT errno_t
_strcat_s_chk (char *restrict dest, rsize_t dmax, const char *restrict src,
               size_t destbos)
{
    static_assert(dmax &amp;lt;= destbos, &amp;quot;dest overflow&amp;quot;);
    static_assert(dmax != 0, &amp;quot;dmax is zero&amp;quot;);
    static_assert(dest != NULL, &amp;quot;dest is null&amp;quot;);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with &lt;code&gt;#define strcat_s(dest,dmax,src) _strcat_s_chk(dest,dmax,src,BOS(dest))&lt;/code&gt;
Very few optimizers will be able to deduce dmax to be a compile-time constant into
&lt;code&gt;_strcat_s_chk&lt;/code&gt;, even if we calculate BOS before calling the function and pass it into it.&lt;/p&gt;

&lt;p&gt;So &lt;strong&gt;gcc sucks big time when compared to clang&lt;/strong&gt;.  Also when we
benchmark our own
&lt;a href=&#34;https://github.com/rurban/safeclib/blob/master/tests/perf_memcpy_s.c&#34;&gt;memcpy_s&lt;/a&gt;
implementation against the assembler optimized memcpy from
libc. clang-5 can now easily vectorize and unroll the memcpy loop, and
my own &lt;code&gt;memcpy_s()&lt;/code&gt; in pure portable C is now as fast as the system
&lt;code&gt;memcpy()&lt;/code&gt; written in assembler, even if my memcpy_s does perform all
the necessary overflow and validity checks. The trick is that most of
that checks are done at compile-time already. gcc is twice as slow.&lt;/p&gt;

&lt;h1 id=&#34;freebsd-glibc-hate-for-the-constraint-handler-crap&#34;&gt;FreeBSD/glibc hate for the constraint-handler &amp;ldquo;crap&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;One reason why the secure C11 Annex K API is not yet added to the various
libc&amp;rsquo;s is not only because it was written and designed by Microsoft.
The public reason given is the mandatory constraint handler, which by
default does nothing in case of errors. But it can be set to a
user-defined handler, which logs those errors.&lt;/p&gt;

&lt;p&gt;With the new configure option &lt;code&gt;--disable-constraint-handler&lt;/code&gt; you can
now disable this feature and avoid this &amp;ldquo;crap&amp;rdquo;. But the performance
win is not measurable, only the binary size will go down. Because all
the static error strings will be left out of the &lt;code&gt;.cstring&lt;/code&gt; section
in the binary. The performance is unchanged, because the handler is
only called in case of errors.&lt;/p&gt;

&lt;p&gt;But bsd/glibc are proud of their various MALLOC hooks, via run-time
getenv checks to help in bug hunting. The safeclib constraint handler
mechanism is much more performant than this, but you need to recompile
your software with a different constraint handler, or prepare such a
getenv check and install a handler at run-time.
There&amp;rsquo;s no technical reason not to use it as designed.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll certainly add lot of BOS checks to cperl also, esp. for XS
programmers. It was extremely useful when developing apps with
safeclib, and gcc is side-lined until they can come up with proper
retpoline cmdline options and constant-folding support to catch errors
when writing code, not in the test-suite or at the customer site.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The sad state of foldcase and string comparisons</title>
      <link>http://perl11.org/blog/foldcase.html</link>
      <pubDate>Sat, 16 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/foldcase.html</guid>
      <description>

&lt;p&gt;You probably heard about case-folding or &lt;strong&gt;foldcase&lt;/strong&gt; before.
Unicode defines CaseFolding mappings for some upper-case characters,
which in full casefolding mode will expand some exotic characters
to larger sequences. In simple mode it will do 1:1 &lt;code&gt;tolower()&lt;/code&gt; mappings.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The &lt;strong&gt;perl&lt;/strong&gt; documentation has this to say:&lt;/p&gt;

&lt;h2 id=&#34;fc&#34;&gt;&lt;strong&gt;fc&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Returns the casefolded version of EXPR. This is the internal function
implementing the &amp;ldquo;\F&amp;rdquo; escape in double-quoted strings.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Casefolding is the process of mapping strings to a form where case
differences are erased; comparing two strings in their casefolded form
is effectively a way of asking if two strings are equal, regardless of
case.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Roughly, if you ever found yourself writing this&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lc($this) eq lc($that)    # Wrong!
    # or
uc($this) eq uc($that)    # Also wrong!
    # or
$this =~ /^\Q$that\E\z/i  # Right!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Now you can write&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fc($this) eq fc($that)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;And get the correct results.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;So far there is no bug and everything is fine.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Unicode&lt;/strong&gt; has this say:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr44/#Casemapping&#34;&gt;http://www.unicode.org/reports/tr44/#Casemapping&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Case for bicameral scripts and case mapping of characters are
complicated topics in the Unicode Standardâboth because of their
inherent algorithmic complexity and because of the number of
characters and special edge cases involved.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This section provides a brief roadmap to discussions about these
topics, and specifications and definitions in the standard, as well as
explaining which case-related properties are defined in the UCD.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://unicode.org/reports/tr21/tr21-5.html#Caseless_Matching&#34;&gt;http://unicode.org/reports/tr21/tr21-5.html#Caseless_Matching&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The &lt;a href=&#34;http://www.unicode.org/reports/tr44/tr44-20.html#Casemapping&#34;&gt;CaseFolding&lt;/a&gt; file
in the Unicode Character Database is used for performing
locale-independent case-folding. This file is generated from the case
mappings in the Unicode Character Database, using both the
single-character mappings and the multi-character mappings. It folds
all characters having different case forms together into a common
form. To compare two strings for caseless matching, you can fold each
string using this data, and then use a binary comparison.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Generally, where case distinctions are not important, other distinctions between Unicode characters (in particular, compatibility distinctions) are ignored as well. In such circumstances, text can be normalized to Normalization Form KC or KD after case-folding, to produce a normalized form that erases both compatibility distinctions and case distinctions. (See UTR #15: Unicode Normalization Forms for more information.) However, such normalization should generally only be done on a restricted repertoire, such as identifiers (alphanumerics).&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;w3.org&lt;/strong&gt; gets closer to the real problem:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.w3.org/International/wiki/Case_folding&#34;&gt;https://www.w3.org/International/wiki/Case_folding&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;One of the most common things that software developers do is &amp;ldquo;normalize&amp;rdquo; text for the purposes of comparison. And one of the most basic ways that developers are taught to normalize text for comparison is to compare it in a &amp;ldquo;case insensitive&amp;rdquo; fashion. In other cases, developers want to compare strings in a case sensitive manner. Unicode defines upper, lower, and title case properties for characters, plus special cases that impact specific language&amp;rsquo;s use of text.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Many developers believe that that a case-insensitive comparison is achieved by mapping both strings being compared to either upper- or lowercase and then comparing the resulting bytes. The existence of functions such as &amp;lsquo;strcasecmp&amp;rsquo; in some C libraries, for example, or common examples in programming books reinforces this belief:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (strcmp(toupper(foo),toupper(bar))==0) { // a typical caseless comparison
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Alas, this model of case insensitive comparison breaks down with some languages. It also fails to consider other textual differences that can affect text. For example, [Unicode Normalization] could be needed to even out differences in e.g. non-Latin texts.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This document introduces case-folding and case insensitivity; provides some examples of how it is implemented in Unicode; and gives a few guidelines for spec writers and others who with to reference comparison using case folding.&lt;/em&gt; &amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Consider Unicode Normalization in addition to case folding. If you mean to find text that is semantically equal, you may need to normalize the text beyond just case folding it. Note that Unicode Normalization does not include case folding: these are separate operations.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;As you might have understood from now, the foldcase API needs to add a
normalization step to the case-folding step.&lt;/p&gt;

&lt;p&gt;Otherwise you will not find &lt;code&gt;&amp;quot;CafeÌ&amp;quot;&lt;/code&gt; in &lt;code&gt;&amp;quot;CafÃ©&amp;quot;&lt;/code&gt;, the first using the
decomposed &lt;code&gt;&amp;quot;e\x301&amp;quot;&lt;/code&gt;, the second using the composed &lt;code&gt;&amp;quot;\e9&amp;quot;&lt;/code&gt; for the
last small e with grave. cperl and python3 do this for
all &lt;a href=&#34;unicode-identifiers.html&#34;&gt;identifiers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;case-folding expands certain characters to longer strings, NFD
normalization even more, NFC normalization will contract them at last
with some additional memory and cpu costs.&lt;/p&gt;

&lt;p&gt;Without normalization you will not be able to compare multi-byte
strings properly.&lt;/p&gt;

&lt;p&gt;perl has this bug since 5.16. Every other language has this bug also,
but doesnât brag about proper full foldcaseâing in its docs as perl
does.&lt;/p&gt;

&lt;p&gt;For performance cperl and safeclib (my C11 libc) implements &lt;code&gt;fc&lt;/code&gt; with
NFD. (Same as Apple in its HPFS btw).&lt;/p&gt;

&lt;p&gt;Note that not even libc implements a proper &lt;code&gt;wcsfc()&lt;/code&gt; or
&lt;code&gt;wcsnorm()&lt;/code&gt;. You cannot compare multi-byte strings in POSIX, only with
gnulib or ICU, but they are massively over-architectured, still
unusable for e.g. coreutils. E.g. grep would really like to find
strings. Only cperl will do so properly after &lt;a href=&#34;https://github.com/perl11/cperl/issues/332&#34;&gt;#332&lt;/a&gt; has landed (it&amp;rsquo;s
already implemented in safeclib). awk, grep, perl5, perl6, ruby,
python, go, silversearch, go platinum searcher, rust ripgrep, &amp;hellip; do
not. They all fail on normalization issues, and with grep you don&amp;rsquo;t
know if it&amp;rsquo;s multi-byte patched at all.&lt;/p&gt;

&lt;p&gt;safeclib is the first library to implement proper foldcasing in
C. FreeBSD will take it from there.&lt;/p&gt;

&lt;h2 id=&#34;details&#34;&gt;Details&lt;/h2&gt;

&lt;p&gt;Unicode is pretty established, some use it with the &lt;code&gt;wchar_t&lt;/code&gt; API in
POSIX, some more as non-POSIX via external non-standardized utf-8 libraries.
The defacto standard there is &lt;a href=&#34;https://github.com/JuliaLang/utf8proc&#34;&gt;utf8proc&lt;/a&gt;, which is now maintained with julia.
This is highly recommended.&lt;/p&gt;

&lt;p&gt;gnulib found out about this problem when people started asking for
multi-byte support in the coreutils. People would really like to find
strings also in foreign documents.  So Bruno Haible, the author of
gnulib (and clisp) added libunistring, with support for u32 and u16
and later even u8 (i.e. utf-8 not single-bytes).&lt;/p&gt;

&lt;p&gt;The first problem is that gnulib is GPL-infected, the second is that
libunistring is too big and too slow to be usable for the coreutils.
Suse and Redhat added the unsupported multi-byte patch for some
years now, but the situation is still unsolved, and you frequently
hear about 8x slower basic utilities with utf-8 locales.&lt;/p&gt;

&lt;h2 id=&#34;multi-byte-support&#34;&gt;Multi-byte support&lt;/h2&gt;

&lt;p&gt;A good overview is this document:
&lt;a href=&#34;http://crashcourse.housegordon.org/coreutils-multibyte-support.html&#34;&gt;http://crashcourse.housegordon.org/coreutils-multibyte-support.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;so-what-s-the-technical-problem&#34;&gt;So what&amp;rsquo;s the technical problem?&lt;/h2&gt;

&lt;p&gt;Technically you need to search in a range of integers from &lt;code&gt;1&lt;/code&gt; to
&lt;code&gt;0x10fff&lt;/code&gt; for case-folding expansions, and then for composed
characters which need to be decomposed.&lt;/p&gt;

&lt;p&gt;There are several established ways to search an integer in a known
static large sparse array:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;linear search&lt;/strong&gt; is done by musl libc in &lt;a href=&#34;https://github.com/rurban/musl/commits/master&#34;&gt;&lt;code&gt;towctrans.c&lt;/code&gt;&lt;/a&gt;, and musl even does
not stop searching after it cannot find the integer anymore. It always
does a full range sweep over all ranges.
I&amp;rsquo;ve fixed that, and musl is now as fast as glibc in case transformations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;perl5 also does linear search, but does it even more stupid than
musl. It&amp;rsquo;s about 8000x slower than a normal search for unicode
properties as implemented in cperl. cperl needed it faster, because
cperl supports unicode indentifiers, and such identifiers need to be
normalized.  perl does not have case-insensitive identifiers, so
case-mapping is not done yet, it will be implemented in the next
month for the &lt;code&gt;m//i&lt;/code&gt; (case-insensitive regexp match) case. Currently
when perl needs to do case-transformation it loads some perl source
code from generated mapping tables, from a big file, transforms this
into an array, transforms this into a reverse range array, stores
this reverse range array in some global perl data as INVLIST
datatype, which is btw. not shared amongst threads or forks, and
then searches via slow perl source ops in these ranges. You cannot
possible think of a slower thing to do. Normally you would prepare
such tables as C code and then generate shared library for
it. Only the external library Encode does it this way, for its
encodings transformations.  But still, perl5 has the best unicode
support of all languages, just also the slowest.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;trie search&lt;/strong&gt;: There&amp;rsquo;s a nice helper module in perl &lt;code&gt;CharClass::Matcher&lt;/code&gt;
under &lt;code&gt;regen/regcharclass.pl&lt;/code&gt; which generates C code for some
typical unicode properties, as trie. It&amp;rsquo;s not a binary trie, it does
not start in the middle of the range, and then recurses into the
lower or upper halfs of the integers. It only starts at the top, so
it&amp;rsquo;s basically a longer linear search, using even more memory than
a linear search, but it supports utf-8, it even searches in multi-byte
utf-8, it generates ASCII and EBCDIC, and it will drive into
recursion overflows when trying to generate more realistic
tables. Such as the case mapping tables or the normalization tables.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;binary search&lt;/strong&gt;: You start in the middle and recurse into the lower
and upper halfs. The problem here is the amount of memory needed to
store the full range of &lt;code&gt;1..0x10fff&lt;/code&gt;. You don&amp;rsquo;t want to do
that. Only glibc does that. Search is log n, but memory is n.
You could binary search over some range tables though.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;glibc uses a full unicode array with a bitcompressed scheme of
  the properties.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2 or 3-stage tables&lt;/strong&gt;: that&amp;rsquo;s what perl &lt;code&gt;Unicode::Normalize&lt;/code&gt; and
gnulib/libunistring does and
&lt;a href=&#34;http://www.unicode.org/versions/Unicode10.0.0/ch05.pdf&#34;&gt;Unicode 5.1 Data Structures for Character Conversion&lt;/a&gt; recommends.
Both use 3 nested tables of 256 elements planes. Since the entries
are sparse, most elements are NULL, and the final tables holds the
values.  This saves some space, and search is 3.  However space is
still not optimal. I improved the Unicode::Normalize generated
tables by using another indirection and store the unique values in
seperate tables, sorted by element size.  E.g. for the Canonical
Decomposition table the value lengths are &lt;code&gt;(917,762,227,36)&lt;/code&gt;, which
is perfect for this kind of scheme.  But for the Compatible
Decomposition table the lengths are &lt;code&gt;(1664,1190,638,109,16,14,1,1)&lt;/code&gt;
and then a final arabic letter which expands to 18 at the end. This
one can be special cased, but the rest cannot be optimized to use
indirection with a 16bit short, you need to use 32bit, and then the
old scheme is better.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;libunistring/gnulib divides its generated tables into 3 levels and
  does some additional manual logic as it sees fit.  For tricky tables
  like the composition table it uses gperf, which goes down to 11Kb
  (array size 1527 for 928 entries).  Some logic is extracted into
  iterators, e.g. the case-folding is locale-specific, and there are
  special rules for turkish and lithuanian, which is added via custom
  iterator passes. This is slow. Think of custom LLVM passes over your
  code. safeclib hardcoded those simple rules.&lt;/p&gt;

&lt;p&gt;Note that coreutils will use this eventually, but tried so far over
  10 years already.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;perfect hashes&lt;/strong&gt;: This is what ICU does. But it&amp;rsquo;s only a simple
perfect hash.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You could analyze the bit patterns and try to find a fast search
  algorithm for the numbers. gperf does a little bit of this. This
  could be the perfect algorithm as it would use the least amount of
  memory, and would be still pretty fast. Unfortunately there does not
  exist a good perfect hash algorithm for such integer ranges as used
  in the Unicode tables.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll try to come up with something new.  A strict hash table as used
  in the most popular schemes via one indirection tables would be too
  big, a hybrid approach would be needed to generate logic branches
  with some nested binary search or hash tables, which in the end also
  can have logic to search in the collision list. It doesn&amp;rsquo;t need to
  be perfect perfect, just optimal. The cost function would be easy,
  as branches, search cost, code size and data size would be easy to
  come up with. But it doesn&amp;rsquo;t exist yet. And Unicode changes its
  tables every year.&lt;/p&gt;

&lt;p&gt;As you see with ICU and partially with libunistring the amount of
memory is still massive and prohibitive. coreutils will not use it,
and honestly such a basic problem of string comparison and string
searching should be in the libc, and properly solved. And only this,
not much else. Other unicode properties can be another optional shared
library.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why I added those functions to
my &lt;a href=&#34;https://github.com/rurban/safeclib/commits/wcsnorm&#34;&gt;safeclib&lt;/a&gt;,
which was written 2008 by Cisco under the MIT license to add the
missing secure C11 Annex K functions with the &lt;code&gt;_s&lt;/code&gt; suffix. Cisco
stopped at about 60 functions and I recently all the other missing C11
functions, now at 134.  After about 10 years of C11 still
&lt;a href=&#34;https://rurban.github.io/safeclib/doc/safec-3.0/d1/dae/md_doc_libc-overview.html&#34;&gt;almost nobody implements full C11&lt;/a&gt;. You
need to use Windows, Android or Embarcadero on embedded systems, or
you need to add safeclib.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/rurban/safeclib/blob/wcsnorm/src/extwchar/wcsfc_s.c&#34;&gt;&lt;code&gt;wcsfc_s()&lt;/code&gt;&lt;/a&gt; does
secure foldcasing, i.e. full Unicode case-folding and NFD
normalization, with the minimal amount of memory used.  It uses my
generated tables for case-folding and canonical decomposition.
case-folding is the extended version of the musl
&lt;a href=&#34;https://github.com/rurban/safeclib/blob/wcsnorm/src/extwchar/towctrans.c&#34;&gt;&lt;code&gt;towctrans&lt;/code&gt;&lt;/a&gt;,
fixed to stop searching early and updated to latest Unicode, and
normalization with the improved version of Unicode::Normalize mkheader
with
&lt;a href=&#34;https://github.com/rurban/safeclib/blob/wcsnorm/src/extwchar/unifcan.h&#34;&gt;indirect tables&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/rurban/safeclib/blob/wcsnorm/src/extwchar/wcsnorm_s.c&#34;&gt;&lt;code&gt;wcsnorm_s()&lt;/code&gt;&lt;/a&gt; does normalization to NFC (&lt;em&gt;soon&lt;/em&gt;), and there exist API&amp;rsquo;s for the
intermediate steps, decompose, reorder, compose, but not the compat
modes as they are too big and should not be used. (only for identifiers
maybe).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Attribute arguments</title>
      <link>http://perl11.org/blog/attributes-args.html</link>
      <pubDate>Sat, 27 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/attributes-args.html</guid>
      <description>

&lt;h1 id=&#34;perl5-had-broken-attribute-handling-forever&#34;&gt;perl5 had broken attribute handling forever&lt;/h1&gt;

&lt;p&gt;perl5 attributes were invented to provide extendable hooks to attach
data or run code at any data, and made for nice syntax, almost
resembling other languages.&lt;/p&gt;

&lt;p&gt;E.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $i :Int = 1;
sub calc :prototype($$) { shift + shift }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There were a few number of builtin attributes, like &lt;code&gt;:lvalue&lt;/code&gt;,
&lt;code&gt;:shared&lt;/code&gt;, &lt;code&gt;:const&lt;/code&gt;, adding a flag to a function or data, and you could
add package-specific for compile-time or run-time hooks to process arbitrary custom
attributes.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;&amp;amp;MyClass::FETCH_SCALAR_ATTRIBUTES&lt;/code&gt; hook would be called on every
not-builtin &lt;code&gt;MyClass::&lt;/code&gt; scalar attribute at run-time, and
&lt;code&gt;&amp;amp;MyClass::MODIFY_SCALAR_ATTRIBUTES&lt;/code&gt; at compile-time.&lt;/p&gt;

&lt;p&gt;If you would want to process attributes in all classes you&amp;rsquo;d need to add &lt;code&gt;UNIVERSAL&lt;/code&gt; hooks
or use handlers like &lt;code&gt;Attribute::Handlers&lt;/code&gt;.
This would simplify declaring code for attributes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub Good : ATTR(SCALAR) {
    my ($package, $symbol, $referent, $attr, $data) = @_;

    # Invoked for any scalar variable with a :Good attribute,
    # provided the variable was declared in MyClass (or
    # a derived class) or typed to MyClass.

    # Do whatever to $referent here (executed in CHECK phase).
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the last &lt;code&gt;$data&lt;/code&gt; argument above. This is the optional argument
for an &lt;code&gt;:Good&lt;/code&gt; attribute, such as in
&lt;code&gt;my MyClass $obj :Good(print a number);&lt;/code&gt;. Do you see the problem?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$data&lt;/code&gt; will be the result of the evaluation of &lt;code&gt;print a number&lt;/code&gt;.
Which will create this error: &lt;code&gt;Can&#39;t locate object method &amp;quot;a&amp;quot; via package &amp;quot;number&amp;quot;&lt;/code&gt;.
This would be the correct declaration: &lt;code&gt;my MyClass $obj :Good(&amp;quot;print a number&amp;quot;);&lt;/code&gt;.
So &lt;code&gt;Attribute::Handlers&lt;/code&gt; is entirely unsafe by evaluating all attribute arguments.&lt;/p&gt;

&lt;p&gt;But Damian was right thinking of the use-cases. Attribute arguments
are needed to attach certain data to a variable of function. He just
didn&amp;rsquo;t implement it properly, as with all of his modules.&lt;/p&gt;

&lt;p&gt;E.g. in cperl we added type support via attributes:
&lt;code&gt;sub calc ($a:int) :int { $a + 10 }&lt;/code&gt; declares calc as returning an &lt;code&gt;int&lt;/code&gt; type, and the
&lt;code&gt;$a&lt;/code&gt; argument to accept &lt;code&gt;int&lt;/code&gt; types.&lt;/p&gt;

&lt;p&gt;For the upcoming cperl ffi (Foreign FunctionCall Interface) we need
attribute arguments more urgently.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sub random () :native :long;&lt;/code&gt; declares random as native function,
searched in all loaded shared libraries. I.e. &lt;code&gt;libc&lt;/code&gt; must already be
loaded. It is by default, so this works. But for non-default shared
libraries we need to specify the name of the library.&lt;/p&gt;

&lt;p&gt;Look e.g. at this perl6 NativeCall declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use NativeCall;
sub mysql_init( OpaquePointer $mysql_client )
    returns OpaquePointer
    is native(&#39;libmysqlclient&#39;)
    { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course this syntax is not ideal.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;returns OpaquePointer&lt;/code&gt; is abbrevated in cperl to &lt;code&gt;:OpaquePointer&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is native(&#39;libmysqlclient&#39;)&lt;/code&gt; has the syntax &lt;code&gt;:native(&#39;mysqlclient&#39;)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The empty &lt;code&gt;{ ... }&lt;/code&gt; block is of course left out. Ditto for &lt;code&gt;{ * }&lt;/code&gt;. This is superfluous syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A ffi declaration is just a declaration without a body. The body is looked up by the native
attribute, in the declared library, and optionally under the &lt;code&gt;:symbol(&#39;mysql_init&#39;)&lt;/code&gt; name.
See the &lt;a href=&#34;https://docs.perl6.org/language/nativecall#Changing_names&#34;&gt;p6 nativecall docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;cperl syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use NativeCall;
extern sub mysql_init( OpaquePointer $mysql_client ) :OpaquePointer :native(&#39;mysqlclient&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;extern sub&lt;/code&gt; declaration is syntax sugar, &lt;code&gt;extern&lt;/code&gt; means the same
as &lt;code&gt;:native&lt;/code&gt;, it just looks better, as in better languages.&lt;/p&gt;

&lt;h1 id=&#34;attribute-arguments&#34;&gt;Attribute arguments&lt;/h1&gt;

&lt;p&gt;Now to the &lt;code&gt;:native&lt;/code&gt; argument, the name of library. You saw in the
first zavolaj example the &lt;code&gt;lib&lt;/code&gt; prefix stated explictly. &lt;code&gt;is native(&#39;libmysqlclient&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will not work on windows and cygwin.  cygwin needs a &lt;code&gt;cyg&lt;/code&gt; prefix
and a version suffix, the dll is called &lt;code&gt;cygmysqlclient-18.dll&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On windows the library would be called &lt;code&gt;libmysql.dll&lt;/code&gt;, but this varies
wildly, as there&amp;rsquo;s no naming convention for shared libs, only for
import libs.&lt;/p&gt;

&lt;p&gt;The world is not made for FFI&amp;rsquo;s, just for linking libraries at
compile-time. There a &lt;code&gt;-lmysqlclient&lt;/code&gt; is enough, on windows this would
find &lt;code&gt;libmysqlclient.dll.a&lt;/code&gt; or &lt;code&gt;libmysqlclient.lib&lt;/code&gt;, which is an
import library which refers to the proper versioned name of the
current shared library. Remember that windows does not solve the
versionining problem of shared libraries via symlinks. One does not
load shared libraries directly on Windows.&lt;/p&gt;

&lt;p&gt;So your FFI mysql connector would do some little application logic, like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $libname = &amp;quot;mysqlclient&amp;quot;;
    $libname = &amp;quot;cygmysqlclient-18.dll&amp;quot; if $^O eq &#39;cygwin`;
    
    sub mysql_init( OpaquePointer $mysql_client ) :OpaquePointer :native($libname);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It cannot be solved in the native attribute handler unless you add the
version, like &lt;code&gt;:native(&#39;mysqlclient&#39;, 18)&lt;/code&gt;. Then the library searcher
can add some magic to find the proper shared library.  But it is
usually done application specific.&lt;/p&gt;

&lt;p&gt;But all this will not work in perl5, as perl5 has no proper way to resolve the
attribute argument &lt;code&gt;$libname&lt;/code&gt; at run-time. What perl5 does is parsing
&lt;code&gt;:native($libname)&lt;/code&gt; to the string &lt;code&gt;&#39;native($libname)&#39;&lt;/code&gt; and passes it
to &lt;code&gt;BEGIN { use attributes ... &#39;:native($libname)&#39;; }&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note &lt;code&gt;&#39;:native($libname)&#39;&lt;/code&gt; and not &lt;code&gt;&amp;quot;:native($libname)&amp;quot;&lt;/code&gt;,
i.e. &lt;code&gt;$libname&lt;/code&gt; is not expanded to it&amp;rsquo;s value, and it would not help much
as the call happens at compile-time, so &lt;code&gt;$libname&lt;/code&gt; would have been empty still.&lt;/p&gt;

&lt;p&gt;What it should have done instead is to inject the code
&lt;code&gt;use attributes ... &amp;quot;native($libname)&amp;quot;;&lt;/code&gt;, which is the equivalent of&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEGIN { require attributes; }
attributes-&amp;gt;import(__PACKAGE__, \&amp;amp;msql_init, &amp;quot;native&amp;quot;, $libname);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which means the import call needs to be deferred to run-time. perl5
does this only for &lt;strong&gt;my&lt;/strong&gt; variable attribute parsing, but not for functions.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;my $var :native($libname)&lt;/code&gt; would correctly call the importer at
run-time, but &lt;code&gt;sub random() :native($libname);&lt;/code&gt; would falsely call the
importer at compile-time, and the argument would not be parsed at
all. Everything is passed as string to the importer, and the hook
needs to parse the argument. Hence the Attribute:Handler security
nightmare, simply calling eval on all args. Which is a lot of fun
e.g. with a documentation attribute with &lt;code&gt;App::Rad&lt;/code&gt;, when your
docstring is eval&amp;rsquo;ed.&lt;/p&gt;

&lt;p&gt;Now with cperl there are now two kind of builtin attributes. The old
:prototype args are still compiled as barewords, but the new :native
and :symbol attribute args (and probably more upcoming) are compiled
as data, with constant strings being compiled at compile-time, and
scalar values being defered to run-time.  Just as with &lt;code&gt;use attributes
&amp;quot;native&amp;quot;, $libname;&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;internally&#34;&gt;Internally&lt;/h1&gt;

&lt;p&gt;Internally perl5 has 3 attrs API&amp;rsquo;s. Two of them are useful, if still broken.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;apply_attrs&lt;/code&gt; is the compile-time variant, passing the verbatim string
with the argument to the attribute import call at compile-time.&lt;/p&gt;

&lt;p&gt;This translates &lt;code&gt;sub func :native($libname)&lt;/code&gt; to
&lt;code&gt;BEGIN { use attributes __PACKAGE__, \&amp;amp;func, &#39;native($libname)&#39;; }&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;apply_attrs_my&lt;/code&gt; is the run-time variant, passing the verbatim string
with the argument to the attribute import call at run-time.&lt;/p&gt;

&lt;p&gt;This translates &lt;code&gt;my $var :native($libname);&lt;/code&gt; to &lt;code&gt;my $var; use
attributes __PACKAGE__, \&amp;amp;var, &#39;native($libname);&lt;/code&gt;.  This is almost
correct. At least the import is done at run-time, and the attribute
handler will have a chance to handle the value of the thing inside the
parens. So eval will work there.&lt;/p&gt;

&lt;p&gt;cperl detects in the lexer scalar variables from attribute arguments,
constructs a proper list for the argument,
and passes it to &lt;code&gt;apply_attrs()&lt;/code&gt;, which then tries to detect needed
run-time deferral. And if so calls &lt;code&gt;apply_attrs_my()&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;This translates &lt;code&gt;my $var :native($libname);&lt;/code&gt; to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $var; use attributes __PACKAGE__, \$var, &#39;native&#39;, $libname;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And &lt;code&gt;sub func :native($libname);&lt;/code&gt; to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub func; use attributes __PACKAGE__, \&amp;amp;func, &#39;native&#39;, $libname;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third internal API &lt;code&gt;apply_attrs_string&lt;/code&gt; is extremely naive and
only useful to process simple &lt;code&gt;ATTRS:&lt;/code&gt; token in XS declarations. It
cannot handle utf8, and splits arguments by space, not being able to
handle nested parens. And then it calls the importer at compile-time.&lt;/p&gt;

&lt;p&gt;In cperl I added an &lt;code&gt;attrs_runtime()&lt;/code&gt; API, which looks at the list of
attrs from the lexer, and calls the runtime variant &lt;code&gt;apply_attrs_my&lt;/code&gt; when
a scalar variable or function call is detected.&lt;/p&gt;

&lt;p&gt;So far I treat :native and :symbol barewords as constant strings and
not as function calls.
I.e. &lt;code&gt;:native(mysqlclient)&lt;/code&gt; does not call the mysqlclient function to return the name.
Attribute::Handler would do that. I&amp;rsquo;ll probably add that with the more explicit
&lt;code&gt;:native(&amp;amp;mysqlclient)&lt;/code&gt; syntax.&lt;/p&gt;

&lt;h1 id=&#34;why-attributes&#34;&gt;Why attributes?&lt;/h1&gt;

&lt;p&gt;A better idea than attributes to attach data would have been metadata
as methods, because then you could also query the current values. With
attributes you can only set it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\&amp;amp;mysql_ffi_fetch-&amp;gt;NATIVE = &amp;quot;mysqlclient.6.so&amp;quot;;
print \&amp;amp;mysql_ffi_fetch-&amp;gt;NATIVE, \&amp;amp;mysql_ffi_fetch-&amp;gt;SYMBOL;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would be independent of packages, and much easier than with
package specific &lt;code&gt;FETCH_CODE_ATTRIBUTES&lt;/code&gt; hooks. You just query the
data. And the magic method would be &lt;strong&gt;lvalue&lt;/strong&gt;, so it could be used as
getter and setter.&lt;/p&gt;

&lt;p&gt;But for compatibility with other languages attributes do make a fine
syntax to declare data properties. So cperl will continue to use the perl5
attribute syntax for perl6 &lt;code&gt;traits&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;see-also&#34;&gt;See also&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/perl11/cperl/issues/22&#34;&gt;ffi #22&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/perl11/cperl/issues/291&#34;&gt;Resolve core attribute arguments, runtime setters, safely #291&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/perl11/cperl/commits/feature/gh22-ffi&#34;&gt;feature/gh22-ffi branch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-6dmzkg-attribute-arguments&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/6dmzkg/attribute_arguments/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>strict names</title>
      <link>http://perl11.org/blog/strict-names.html</link>
      <pubDate>Thu, 18 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/strict-names.html</guid>
      <description>

&lt;h1 id=&#34;consistent-identifier-parsing-rules&#34;&gt;Consistent identifier parsing rules&lt;/h1&gt;

&lt;p&gt;perl5 and cperl older than 5.27.0 accepts any string as valid
identifier name when being created under &lt;code&gt;no strict &#39;refs&#39;&lt;/code&gt; at
run-time, even when most such names are illegal, and cannot be handled
by most external modules.
Even invalid unicode is allowed.&lt;/p&gt;

&lt;p&gt;cperl 5.26 fixed embedded NUL&amp;rsquo;s and invalid unicode
identifiers &lt;a href=&#34;https://github.com/perl11/cperl/issues/233&#34;&gt;illegal&lt;/a&gt;,
and
&lt;a href=&#34;https://github.com/perl11/cperl/issues/228&#34;&gt;normalizes unicode identifiers&lt;/a&gt; in
the parser.&lt;/p&gt;

&lt;p&gt;Since cperl 5.27.1 dynamically created names are treated the same way
as when they are parsed. Which means illegal utf8 names are
rejected, unicode names are now normalized at run-time in the rv2sv
OP, via &lt;code&gt;${&amp;quot;string&amp;quot;}&lt;/code&gt; and mixed unicode scripts are also checked.&lt;/p&gt;

&lt;h1 id=&#34;strict-names&#34;&gt;strict names&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;strict &amp;lsquo;names&amp;rsquo;&lt;/strong&gt; is now implemented, included in the default and
enabled with cperl 5.27.1. It checks
for &lt;a href=&#34;http://perl11.org/cperl/perldata.html#Identifier-parsing&#34;&gt;valid identifiers&lt;/a&gt; being
created from strings under &lt;code&gt;no strict &#39;refs&#39;&lt;/code&gt; at run-time to match the
same rules as when they would have been created at compile-time by the
parser. Which helps
in &lt;a href=&#34;unicode-identifiers.html&#34;&gt;fighting invalid identifiers&lt;/a&gt;, which
cannot be handled by the rest of perl.
There was still room left to create invalid and
potentially harmful utf8 or binary names at run-time via &lt;code&gt;no strict &#39;refs&#39;&lt;/code&gt;.
strict names ensures no illegal name will get created.&lt;/p&gt;

&lt;p&gt;Note that p5p insists that illegal identifiers are still legal to
create at run-time. Only compile-time illegal identifiers are illegal.&lt;/p&gt;

&lt;p&gt;Currently it clashes with a reserved VMS hint. That means on VMS
strict names will be implemented in a slower way, via a hints hash
key, not a hints scalar bit.&lt;/p&gt;

&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;This was legal before and is now illegal:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    use strict; no strict &#39;refs&#39;;

    ${&amp;quot;\xc3\x28&amp;quot;}
    
    my $s = &amp;quot;\xe2\x28\xa1&amp;quot;;
    ${$s}
    
    ${&amp;quot;$s\::xx&amp;quot;}
    
    ${&amp;quot;\cTAINT&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=&amp;gt; Invalid identifier &amp;ldquo;\24AINT&amp;rdquo; while &amp;ldquo;strict names&amp;rdquo; in use&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This symbol is since 5.26 normalized, previously not.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    use strict; no strict &amp;quot;refs&amp;quot;;
    my $cafÃ© = &amp;quot;cafeÌ&amp;quot;;   # &amp;lt;c, a, f, e, U+0301, U+0301&amp;gt;
    print $cafÃ©;         # &amp;lt;c, a, f, U+00E9&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Empty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cafeÌ
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;And the illegal UTF-8 variant:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;     use strict; no strict &#39;refs&#39;;
     my $cafeÌ = &amp;quot;cafÃ©&amp;quot;; # &amp;lt;c, a, f, e, U+0301, U+0301&amp;gt; 
     print ${$cafÃ©};    # &amp;lt;c, a, f, U+00E9&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Global symbol &amp;quot;$cafÃ©&amp;quot; requires explicit package name (did you forget to declare &amp;quot;my $cafÃ©&amp;quot;?) at -e line 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Malformed UTF-8 character: \x81 (unexpected continuation byte 0x81, with no preceding start byte) in scalar dereference at -e line 3.
Malformed UTF-8 character (fatal) at -e line 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;cpan-impact&#34;&gt;CPAN Impact&lt;/h1&gt;

&lt;p&gt;Not many CPAN modules are affected by strict names being on by
default.  This is expected as strict names mostly protects against
run-time security attacks.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pod-Perldoc: &lt;a href=&#34;https://rt.cpan.org/Ticket/Display.html?id=121771&#34;&gt;https://rt.cpan.org/Ticket/Display.html?id=121771&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;my $version = do { no strict &#39;refs&#39;; ${ &#39;$&#39; . $class . &#39;::VERSION&#39; } };&lt;/code&gt;
=&amp;gt; Invalid identifier &amp;ldquo;$Pod::Perldoc::VERSION&amp;rdquo; while &amp;ldquo;strict names&amp;rdquo; in use&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cperl caught the wrong leading &lt;code&gt;$&lt;/code&gt; here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Scalar-List-Utils: tests for binary names without &lt;code&gt;no strict&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PathTools: File::Spec::Unix&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    my $taint = do { no strict; ${&amp;quot;\cTAINT&amp;quot;} };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default package &lt;code&gt;%main::&lt;/code&gt; is not detected yet with
&lt;code&gt;valid_ident()&lt;/code&gt;, so this fails under strict names, but would pass with
&lt;code&gt;${&amp;quot;::\cTAINT&amp;quot;}&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;EUMM: ExtUtils::MakeMaker::Locale&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Encode::Alias::define_alias(sub {
    no strict; # no strict names: &amp;quot;-&amp;quot; is an invalid IDCont
    no warnings &#39;once&#39;;
    return ${&amp;quot;ENCODING_&amp;quot; . uc(shift)};
}, &amp;quot;locale&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$ENCODING_UTF-8&lt;/code&gt; is an invalid identifier. So don&amp;rsquo;t use strict names.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-6bvokz-strict-names&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/6bvokz/strict_names/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>strict hashpairs</title>
      <link>http://perl11.org/blog/strict-hashpairs.html</link>
      <pubDate>Tue, 16 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/strict-hashpairs.html</guid>
      <description>

&lt;h1 id=&#34;perl5-optionally-warns-on-odd-hash-elements&#34;&gt;perl5 optionally warns on odd hash elements&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;my %h = (0,1,2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is legal code in perl5. The second pair is constructed with the undef value.
With &lt;code&gt;use warnings &#39;misc&#39;&lt;/code&gt; it will warn at least.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use warnings;
my %h = (0,1,2);
=&amp;gt; Odd number of elements in hash assignment (WARNING only)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;perl6-throws-on-odd-hash-elements&#34;&gt;perl6 throws on odd hash elements&lt;/h1&gt;

&lt;p&gt;perl6 is sane and strict by default.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %h = (0..2);
=&amp;gt; Odd number of elements found where hash initializer expected:
Found 3 (implicit) elements:
Last element seen: 2
  in block &amp;lt;unit&amp;gt; at &amp;lt;unknown file&amp;gt; line 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;cperl-5-27-throws-with-use-strict&#34;&gt;cperl 5.27 throws with use strict&lt;/h1&gt;

&lt;p&gt;Since cperl 5.27.0 use strict added two new keys: &lt;strong&gt;&amp;lsquo;hashpairs&amp;rsquo;&lt;/strong&gt; and
&amp;lsquo;names&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;strict hashpairs ensure that no hashes can get created from lists or arrays with odd elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use strict;
my %h = (0,1,2);
=&amp;gt; Only pairs in hash assignment allowed while &amp;quot;strict hashpairs&amp;quot;, got 3 elements
Execution of -e aborted due to compilation errors
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With constant arrays or lists this is even a compile-time error, as seen above.&lt;/p&gt;

&lt;p&gt;With map it is even more strict. With map only a missing or a single
pair is allowed to construct a hash, not multiple pairs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use strict;
my %h = map {$_=&amp;gt;1, $_+1} (0..2);
=&amp;gt; Only pair in map hash assignment allowed while &amp;quot;strict hashpairs&amp;quot;, got 3 elements
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was legal in perl5 and is now a run-time error. Net::DNS did it
to construct two pairs in one loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use strict;
my %h = map {$_} @array;
=&amp;gt; Only pair in map hash assignment allowed while &amp;quot;strict hashpairs&amp;quot;, got 1 elements
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Typical oddities, which are now forbidden:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%h = map { $ =&amp;gt; (0,1) } (0..3);
=&amp;gt; 1=&amp;gt;3, 2=&amp;gt;0, 0=&amp;gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only 3 keys, not 4. Because &lt;code&gt;@h=map{$=&amp;gt;(0,1)}(0..3);print join&amp;quot; &amp;quot;,@h&#39;&lt;/code&gt;
=&amp;gt; &lt;code&gt;0 0 1 1 0 1 2 0 1 3 0 1&lt;/code&gt; and the duplicate keys collapse.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%h = map { $_ } (0..3);
=&amp;gt; 2=&amp;gt;3, 0=&amp;gt;1 (2 keys, of course)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;more-warnings&#34;&gt;More warnings&lt;/h1&gt;

&lt;p&gt;cperl 5.27 added detection for more &amp;ldquo;Odd elements&amp;rdquo; warnings, esp.
when a map assigned to a hash produces no pairs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;no strict;
use warnings;
%h = map { $_ } (0..1);
# =&amp;gt; Odd number of map elements in hash assignment
%h = map { $_ =&amp;gt; (0,1) } (0..1);
# =&amp;gt; Odd number of map elements in hash assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The warning is only produced once for each map, not for every map iteration.&lt;/p&gt;

&lt;h1 id=&#34;cpan-impact&#34;&gt;CPAN Impact&lt;/h1&gt;

&lt;p&gt;One might think changing the strictness of the language might break a lot of modules.
Thanksfully most module authors already use sane coding principles, only a few
produce multiple pairs per map to a hash.&lt;/p&gt;

&lt;p&gt;All of them have been fixed in my distroprefs patches, and some also upstream.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Net-NDS: &lt;a href=&#34;https://rt.cpan.org/Ticket/Display.html?id=121680&#34;&gt;https://rt.cpan.org/Ticket/Display.html?id=121680&lt;/a&gt; &lt;a href=&#34;https://github.com/rurban/distroprefs/commit/63cd16b8359d1ccd062f0c4b913fa77b4b8681ff&#34;&gt;rurban/distroprefs@63cd16b&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Moose: &lt;a href=&#34;https://github.com/rurban/distroprefs/commit/f929f794fc64b5fef3b29c81f5b313c28f60da92&#34;&gt;rurban/distroprefs@f929f79&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DBI: &lt;a href=&#34;https://github.com/rurban/distroprefs/commit/2f0c82d7e938e8d10420c3d76eab235fbb229fff&#34;&gt;rurban/distroprefs@2f0c82d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Class::Tiny &lt;a href=&#34;https://github.com/rurban/distroprefs/commit/02054335a9c30aa3d5d7abfe7ca6002d5ccd4033&#34;&gt;rurban/distroprefs@0205433&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MooseX::Types &lt;a href=&#34;https://github.com/rurban/distroprefs/commit/e1e3fc0fc6f03a6dcc6afdf9afd4ac85abd6076a&#34;&gt;rurban/distroprefs@e1e3fc0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Encode &lt;a href=&#34;https://github.com/dankogai/p5-encode/pull/100&#34;&gt;dankogai/p5-encode#100&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Only one module at all used a double pair in a map, Net::DNS. This was easily fixed.
The other modules use &lt;code&gt;%opts = @_;&lt;/code&gt; to assign a hash from the pairwise arguments of a
subroutine call. Perfectly fine usage.&lt;/p&gt;

&lt;p&gt;It get&amp;rsquo;s crazy with something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %p = map { %{$_} } @_;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in &lt;code&gt;Moose/Util/TypeConstraints.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %attrs = map { %{ Class::MOP::Class-&amp;gt;initialize($_)-&amp;gt;_attribute_map } }
            reverse $self-&amp;gt;linearized_isa;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in &lt;code&gt;Class/MOP/Class.pm&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %defaults = map { ref $_ eq &#39;HASH&#39; ? %$_ : ( $_ =&amp;gt; undef ) } @spec;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in &lt;code&gt;Class/Tiny.pm&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %order = map {
            my $order = $_;
            map { ( $_ =&amp;gt; $order ) } @{ $dbh-&amp;gt;{sql_init_order}{$order} };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in DBI. Here you also see the manual prevention of the problem described
below, protecting the iteration key from the global iterator in nested
map loops.&lt;/p&gt;

&lt;p&gt;These cases just deserve a &lt;code&gt;no strict &amp;quot;hashpairs&amp;quot;&lt;/code&gt; or fix it.&lt;/p&gt;

&lt;p&gt;The typical hackish workaround for such cases is constructing a
temp. @array from the map and then assign the hash from this array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %p = map { %{$_} } @_;

=&amp;gt;

my @p = map { %{$_} } @_;
my %p = @p;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sideeffects-and-wrong-order-of-evaluation-in-map&#34;&gt;Sideeffects and wrong order of evaluation in map&lt;/h1&gt;

&lt;p&gt;And now look at these oddities, detected by Patrick Cronin and rafl for their
new &lt;a href=&#34;https://github.com/PatrickCronin/Map-Functional/&#34;&gt;Map::Functional&lt;/a&gt;
module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub x{$_,&amp;quot;ouch&amp;quot;}; %h = map { $_ =&amp;gt; x } (0..3);
=&amp;gt; %h =&amp;gt; 3=&amp;gt;ouch, ouch=&amp;gt;3, 1=&amp;gt;ouch, 2=&amp;gt;2, 0=&amp;gt;0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5 not 4 keys. Still the normal list comprehension problem..
But what if the value changes the key?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub x{$_ = &amp;quot;ouch&amp;quot;}; %h = map { $_ =&amp;gt; x } (0..3);
=&amp;gt; %h =&amp;gt; ouch=&amp;gt;ouch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A sideffect in the value evaluation changed the key, because the &lt;code&gt;$_&lt;/code&gt;
inside the x subroutine is the same as the global &lt;code&gt;$_&lt;/code&gt; loop iterator
inside map.  They experience problems with the global topic trampled
over inside a loop by various other ops, just as &lt;code&gt;while (&amp;lt;&amp;gt;){}&lt;/code&gt; called from
the value, which changed the key.&lt;/p&gt;

&lt;p&gt;Too bad &lt;a href=&#34;http://blogs.perl.org/users/rurban/2016/04/the-removal-of-the-lexical-topic-feature-in-524.html&#34;&gt;perl5 removed the lexical &lt;code&gt;$_&lt;/code&gt; topic&lt;/a&gt;. This
would at least have saved the loop iterator.&lt;/p&gt;

&lt;p&gt;But it is worse than that. It is even broken without a lexical &lt;code&gt;$_&lt;/code&gt;,
and without a function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%h = map { $_ =&amp;gt; ($_ = &amp;quot;ouch&amp;quot;) } (0..3);
=&amp;gt; %h =&amp;gt; ouch=&amp;gt;ouch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the values inside the map are computed at once, hence the first
&lt;code&gt;$_&lt;/code&gt; is changed also, and the list produced by the map block is
consumed later, when the block is done.  In a proper language with
proper of left to right evaluation order the key would be consumed
first, and then the value.&lt;/p&gt;

&lt;p&gt;The underlying design problem is that the map lambda has no formal argument
list, where you could enforce that order. &lt;code&gt;map sub(a,b){ a =&amp;gt; b } (0..3)&lt;/code&gt;
perl5 just uses a block body with a silent &lt;code&gt;($_)&lt;/code&gt; lambda
signature and the return value(s) just spill over to the stack.&lt;/p&gt;

&lt;p&gt;But it is still solvable by detecting lists inside map blocks and
consume them one by one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;map { $_ =&amp;gt; ($_ = &amp;quot;ouch&amp;quot;) } (0..3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is roughly compiled as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapstart { stmt, stmt } mapwhile rv2av const(AV)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I might change it to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapstart { stmt; mapwhile; stmt } mapwhile rv2av const(AV)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The embedded mapwhile op would consume the first element, push it into
the stack and continue. This would make hash assignments via map much safer.&lt;/p&gt;

&lt;h1 id=&#34;strict-names&#34;&gt;strict names&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;strict &amp;lsquo;names&amp;rsquo;&lt;/strong&gt; is not yet enabled. It will check for valid
identifiers being created from strings under no strict &amp;lsquo;refs&amp;rsquo;. Which
helps in &lt;a href=&#34;unicode-identifiers.html&#34;&gt;fighting invalid identifiers&lt;/a&gt;
being created, which cannot be handled by the rest of perl, and
esp. since 5.16 with additional embedded NUL.  cperl 5.26 made
embedded NUL&amp;rsquo;s and invalid unicode
identifiers &lt;a href=&#34;https://github.com/perl11/cperl/issues/233&#34;&gt;illegal&lt;/a&gt;,
and &lt;a href=&#34;https://github.com/perl11/cperl/issues/228&#34;&gt;normalizes unicode identifiers&lt;/a&gt;. But
there&amp;rsquo;s still room left to create invalid and potentially harmful
unicode names. Some cases are only warned against.  strict names will
ensure no illegal name will get created.&lt;/p&gt;

&lt;p&gt;And it clashes with a reserved VMS hint. Means on VMS strict names will be a no-op.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-6bgya8-strict-hashpairs&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/6bgya8/strict_hashpairs/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Automatic cperl deployments</title>
      <link>http://perl11.org/blog/automatic-deployments.html</link>
      <pubDate>Thu, 27 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/automatic-deployments.html</guid>
      <description>

&lt;h1 id=&#34;binary-packages&#34;&gt;Binary packages&lt;/h1&gt;

&lt;p&gt;perl5 relies on external packagers to update and maintain packages for
various distributions. It only provides source packages as tarballs.&lt;/p&gt;

&lt;p&gt;cperl does a bit better by also providing binary packages for all
major platforms. See also &lt;strong&gt;Installation&lt;/strong&gt; at the
&lt;a href=&#34;http://perl11.org/cperl/STATUS.html&#34;&gt;STATUS&lt;/a&gt; page.
&lt;a href=&#34;http://perl11.org/win/&#34;&gt;win32, win64&lt;/a&gt;, debian 7 i686, debian 8 amd64,
centos 7 x86_64, centos 6 i686+x86_64 and &lt;a href=&#34;http://perl11.org/osx/&#34;&gt;darwin amd64&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Packaging was done with this &lt;a href=&#34;https://github.com/perl11/cperl/blob/master/Porting/do-make-cperl-release&#34;&gt;do-make-cperl-release&lt;/a&gt; script, leading to&lt;/p&gt;

&lt;p&gt;Centos/Fedora/RHEL as el6 or el7 &lt;code&gt;/etc/yum.repos.d/perl11.repo&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[perl11]
name=perl11
baseurl=http://perl11.org/rpm/el7/$basearch
enabled=1
gpgkey=http://perl11.org/rpm/RPM-GPG-KEY-rurban
gpgcheck=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or for Debian/Ubuntu &lt;code&gt;/etc/apt/sources.list.d/perl11.list&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://perl11.org/deb/ sid main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far the packaging was done on private build VM&amp;rsquo;s, and the hosting
was done on github.  Yes, you can easily host deb and rpm distros for
free at github pages.  But the idea is also to use external package
providers, like &lt;a href=&#34;https://build.opensuse.org/&#34;&gt;OpenSUSE OBS&lt;/a&gt;
or &lt;a href=&#34;https://bintray.com/perl11/&#34;&gt;Bintray&lt;/a&gt;, which do packaging and
hosting for many more platforms.&lt;/p&gt;

&lt;h1 id=&#34;autodeploy&#34;&gt;Autodeploy&lt;/h1&gt;

&lt;p&gt;With cperl-5.26.0c the packaging for at least win32 and the new win64
platforms with MSVC12 and darwin is done automatically via tagging a release and pushing it
to &lt;a href=&#34;https://github.com/perl11/cperl/releases&#34;&gt;github&lt;/a&gt;.
For MSVC12 you&amp;rsquo;ll need the &lt;em&gt;msvcr120.dll&lt;/em&gt; runtime,
available e.g. from the Microsoft VS 2013 C++ Redistributable Package
from &lt;a href=&#34;https://www.microsoft.com/en-us/download/details.aspx?id=40784&#34;&gt;https://www.microsoft.com/en-us/download/details.aspx?id=40784&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&#34;https://github.com/perl11/cperl/commit/9a79df78a29fb50a3c2837cdd2a8422fe98b760a&#34;&gt;today&lt;/a&gt; appveyor provides the windows deployments, and &lt;a href=&#34;https://travis-ci.org/perl11/cperl/builds&#34;&gt;travis&lt;/a&gt; the linux src tarballs and darwin deployments.&lt;/p&gt;

&lt;p&gt;Additionally &lt;a href=&#34;https://ci.appveyor.com/project/rurban/cperl/history&#34;&gt;appveyor&lt;/a&gt;
provides also nightly builds on every master change. This is for now
only in private draft releases, but I&amp;rsquo;ll think about enabling it as
pre-releases.&lt;/p&gt;

&lt;p&gt;Travis does not support nightly builds as easy as Appveyor.
With Appveyor you can tag your deployments as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;draft: true
prerelease: true
force_update: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but with Travis you can only deploy tags. So for a nightly you would need to add a
tag for every master change, there&amp;rsquo;s no deploy condition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on:
  appveyor_repo_tag: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on:
  branch: /(master|relprep)/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The missing &lt;code&gt;prerelease&lt;/code&gt; or &lt;code&gt;draft&lt;/code&gt; tag on Travis also means that
every deployment on tags is a proper release, and you have to manually
change that to a &lt;em&gt;Pre-Release&lt;/em&gt; on the github release page. You cannot
change that to an invisible &lt;em&gt;Draft&lt;/em&gt; release.&lt;/p&gt;

&lt;p&gt;The Appveyor &lt;code&gt;force_update: true&lt;/code&gt; deploy tag means that you can start
a deployment from win32/msvc12 and add files from e.g. win64 later to
that github release. Travis always allows that. E.g. the src tarballs
are added first and darwin pkgbuild files are added later.&lt;/p&gt;

&lt;p&gt;One could also think of extending that to CPAN uploads, by encrypting the PAUSE key
and let Travis-CI trigger the cpan upload on every new release tag.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unicode Identifiers</title>
      <link>http://perl11.org/blog/unicode-identifiers.html</link>
      <pubDate>Tue, 07 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/unicode-identifiers.html</guid>
      <description>

&lt;h1 id=&#34;binary-names-with-5-16&#34;&gt;Binary names with 5.16&lt;/h1&gt;

&lt;p&gt;With perl 5.16 added support for binary names, announcing it as
support for unicode names. Unicode names were already supported since
5.8.4 with a negative length stored in the hash key of the symbol.&lt;/p&gt;

&lt;p&gt;Supporting binary names without any supporting measures opened huge
security holes, as names are mapped 1:1 to filenames when searching
for a package, and as we know the C API for files or names just
ignores a \0, leading to inconsistencies. And you could now easily
hide payloads in package names. Remember that p5p never announced this
problem and feature, they only announced it as improved and full
unicode support for names.  In the following years I had to fix most
of the problems with binary names support, but many critical modules
still have no idea, and are still vulnerable. Even the new perl5
maintainer has no idea as he showed in his YAPC talk about XS
programming. He happily used the old &lt;code&gt;gv_&lt;/code&gt; interfaces not supporting
\0, and there&amp;rsquo;s no upgrade path in perl5 for old modules to avoid those
security holes.&lt;/p&gt;

&lt;p&gt;Well, with unicode this would not have been a big problem, as our used
encoding UTF-8 does not support \0. It&amp;rsquo;s also illegal.
Only with cperl-5.26 we finally got back safe names, \0 is illegal again.&lt;/p&gt;

&lt;h1 id=&#34;unicode-security&#34;&gt;Unicode Security&lt;/h1&gt;

&lt;p&gt;But here we want to talk about the unicode problems when a language
decides to embrace unicode names. perl5 prides itself by being one of
the scripting languages with the best unicode support.  Well, the
libraries and strings, yes. But the language itself is still horribly
unicode unsafe.&lt;/p&gt;

&lt;p&gt;The unicode consortium published many security addendums, as TRnn.
Most of them are targetted to html forms, domains names used in
browsers or DNS servers, and email names. The problem with unicode is,
that different names are not identifiable as such, and thus you can
easily fool someone to click on a wrong url. Identifiers need to be
identifiable and restricted.  perl5 and perl6 pride themselves of
anything goes, it does not enforce opinions on their users. Well, it&amp;rsquo;s
still insecure.&lt;/p&gt;

&lt;p&gt;The simpliest unicode problems are tricks with illegal UTF-8
encodings.  This is also relevant to strings and therefore mostly
fixed in perl5 and cperl.&lt;/p&gt;

&lt;p&gt;But there are many more security problems in most programming
languages with unicode support. Only cperl, python3 and perl6 fixed
some of them, by doing normalization of its identifiers.
I didn&amp;rsquo;t see any effort in all the others, besides java.&lt;/p&gt;

&lt;p&gt;The most basic overview is at &lt;a href=&#34;http://websec.github.io/unicode-security-guide/&#34;&gt;http://websec.github.io/unicode-security-guide/&lt;/a&gt;.
Go read it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Because Unicode contains such a large number of characters and
 incorporates the varied writing systems of the world, incorrect usage
 can expose programs or systems to possible security attacks. This is
 especially important as more and more products are
 internationalized. This document describes some of the security
 considerations that programmers, system analysts, standards
 developers, and users should take into account, and provides specific
 recommendations to reduce the risk of problems.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The most important documents are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers&#34;&gt;TR31 Candidate Characters for Exclusion from Identifiers&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr36/&#34;&gt;TR36 Unicode Security Considerations&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr39/&#34;&gt;TR39 Unicode Security Mechanisms&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In short, those problems need to be fixed:&lt;/p&gt;

&lt;h1 id=&#34;mixed-scripts&#34;&gt;Mixed scripts&lt;/h1&gt;

&lt;p&gt;A written language is defined by its scripts (i.e. &amp;ldquo;alphabets&amp;rdquo;). Some
languages allow multiple scripts, such as modern Japanese uses both
logographic (kanji, originated from Chinese hanzi&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;) and syllabic
(kana) characters simultaneously, with two distinct types of kana
(hiragana and katakana).  So if you want to support japanese you need
allow all these three scripts to be used in a program, without any
declaration. Similar for Korean, which sometimes also use some old
Han/Chinese characters, and Chinese which uses the biggest set of
characters Han, plus one additional educational script, called
Bopomofo.&lt;/p&gt;

&lt;p&gt;The problem is very apparent with Cyrillic and Greek. Both are
different languages, but use almost the same characters, which are not
identifiable in any font. If the character is a Greek or Cyrillic
symbol, or if it&amp;rsquo;s one of the mathematical symbols.&lt;/p&gt;

&lt;p&gt;So strict mixed-script profiles for identifiers forbid the default
usage of Greek and Cyrillic characters in the same program.&lt;/p&gt;

&lt;p&gt;In cperl, which is currently the only unicode safe language, this
is forbidden:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8;
my $Î = 1;
if ($Ð) { warn; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;use utf8&lt;/code&gt; declares that identifiers can be unicode, utf-8 encoded.
&lt;code&gt;my $Î = 1&lt;/code&gt; sets a scalar lexical variable to 1, with the name &lt;code&gt;Î&lt;/code&gt;.
What you don&amp;rsquo;t see, only the parser, or if you inspect the program
binary, e.g. with od, is that the first Î character is the greek
gamma, and the second variable uses the cyrillic gamma.
Only with a restricted identifier profile you will see the problem.&lt;/p&gt;

&lt;p&gt;cperl does this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cperl5.26.0 -e&#39;use utf8;my $Î = 1;if ($Ð) { warn }&#39;
Invalid script Cyrillic in identifier Ð) { warn }
for U+0413. Have Greek at -e line 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I.e. it allows the first greek character in a name to be used without
declaration of a foreign script, but then fails when a cyrillic
character in a name appears. With such characters in strings or
buffers the user has to care, but with identifiers the parser has to
care, as the identifier is not identifiable anymore.&lt;/p&gt;

&lt;p&gt;When a user really wants to use names in multiple languages in a
program, he needs to declare them beforehand, so the casual reader is
aware of the mixed scripts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8 (&amp;quot;Greek&amp;quot;, &amp;quot;Cyrillic&amp;quot;);
my $Î = 1;
if ($Ð) { warn }&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is now a somewhat valid variant. But note that mixing Cyrillic and
Greek is still frowned upon, and needs to be warned, even when being
declared as such.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=&amp;gt; Invalid script Cyrillic, cannot be mixed with Greek
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarily, some scripts can be used undeclared, and some need to be
declared.  These recommendations are all specified in the TR39
Restriction levels.&lt;/p&gt;

&lt;h1 id=&#34;visual-spoofing&#34;&gt;Visual spoofing&lt;/h1&gt;

&lt;p&gt;Unicode is pretty good in defining what characters are allowed as
first character in an identifier, and what characters may
follow. These classes are declared in the &lt;code&gt;ID_Start&lt;/code&gt; and
&lt;code&gt;ID_Continue&lt;/code&gt;, see
&lt;a href=&#34;http://www.unicode.org/reports/tr31/#Table_Lexical_Classes_for_Identifiers&#34;&gt;TR 31 Lexical_Classes_for_Identifiers&lt;/a&gt;
for the precise rules properly used in most languages with unicode
support.&lt;/p&gt;

&lt;p&gt;I know only of one bug in these tables, the U+3164 HANGUL FILLER is
wrongly specified as ID_Cont. Thus in perl5 this is valid:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -e&#39;use utf8; $aã¤b == 2;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but cperl detects the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cperl -e&#39;use utf8; $aã¤b == 2;&#39;
Unrecognized character \x{3164}; marked by &amp;lt;-- HERE after e utf8; $a&amp;lt;-- HERE
near column 13 at -e line 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same problem for the U+ffa0 HALFWIDTH HANGUL FILLER. See also
&lt;a href=&#34;https://github.com/jagracey/Awesome-Unicode#user-content-variable-identifiers-can-effectively-include-whitespace&#34;&gt;https://github.com/jagracey/Awesome-Unicode#user-content-variable-identifiers-can-effectively-include-whitespace&lt;/a&gt;
According to according to
&lt;a href=&#34;http://www.unicode.org/L2/L2006/06310-hangul-decompose9.pdf&#34;&gt;http://www.unicode.org/L2/L2006/06310-hangul-decompose9.pdf&lt;/a&gt; those two
fillers á..á  HANGUL CHOSEONG FILLER..HANGUL JUNGSEONG FILLER are the
proper replacements.&lt;/p&gt;

&lt;p&gt;But besides those rare bugs, spoofs and confusables are much more common.
I only know of very few languages which actually detect those problems.&lt;/p&gt;

&lt;p&gt;Spoofs are certain trick character combinations.&lt;/p&gt;

&lt;p&gt;Popular spoof attacks were the Paypal.com IDN spoof of 2005. Setup to
demonstrate the power of these attack vectors, Eric Johanson and The
Schmoo Group successfully used a www.paypal.com lookalike domain name
to fool visitors into providing personal information. The advisory
references original research from 2002 by Evgeniy Gabrilovich and Alex
Gontmakher at the Israel Institute of Technology. Their original paper
described an attack using Microsoft.com as an example. - &lt;a href=&#34;http://websec.github.io/unicode-security-guide/visual-spoofing/&#34;&gt;visual-spoofing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A typical bidi-spoof would involve a unicode aware text-editor or
viewer, and identifiers which switch to right-to-left (arabic),
overwrite the previous characters, and maybe even switch back to
left-to-right. Visually the names look the same, but internally the
spoofed name is much longer.&lt;/p&gt;

&lt;p&gt;Such spoofs are usually prevented with forbidding mixed scripts.&lt;/p&gt;

&lt;h1 id=&#34;normalization&#34;&gt;Normalization&lt;/h1&gt;

&lt;p&gt;Other simple spoofs can be be prevented with normalization. This is
what Python3 started to do, also cperl and java.  With normalization
of unicode character sequences all possible and valid character
combinations are compressed to one single normal form. There are two
defined normal forms, NFKC and NFC, interestingly python decided to
pick the wrong one, normalizing to ligatures. cperl normalizes to the
canonical normal form NFC. perl6 decided to normalize to their own
format, called NFD, which allows invalid, private reserved characters
in upper planes, which will be forbidden in upcoming perl5 and cperl
releases.&lt;/p&gt;

&lt;p&gt;E.g. &lt;code&gt;cafeÌ&lt;/code&gt; (&lt;code&gt;&amp;lt;c, a, f, e, U+0301&amp;gt;&lt;/code&gt;) is normalized to &lt;code&gt;cafÃ©&lt;/code&gt;
&lt;code&gt;&amp;lt;c, a, f, U+00E9&amp;gt;&lt;/code&gt;.
&lt;code&gt;cafeÌÌ&lt;/code&gt;, using two combining marks (&lt;code&gt;&amp;lt;c, a, f, e, U+0301, U+0301&amp;gt;&lt;/code&gt;) is currently allowed.&lt;/p&gt;

&lt;h1 id=&#34;same-script-confusables&#34;&gt;Same Script Confusables&lt;/h1&gt;

&lt;p&gt;There&amp;rsquo;s a whole table of confusables which are still confusable after
restricting mixed scripts and after normalization.
These confusables are typically optionally warned upon.&lt;/p&gt;

&lt;h1 id=&#34;moderately-restrictive-level&#34;&gt;Moderately Restrictive Level&lt;/h1&gt;

&lt;p&gt;cperl as first dynamic scripting language follows the &lt;strong&gt;General
Security Profile&lt;/strong&gt; for identifiers in programming languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Moderately Restrictive&lt;/strong&gt;: Allow &lt;code&gt;Latin&lt;/code&gt; with other Recommended or
Aspirational scripts except &lt;code&gt;Cyrillic&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt;. Otherwise, the same as
&lt;a href=&#34;http://www.unicode.org/reports/tr39/#Identifier_Characters&#34;&gt;Highly Restrictive&lt;/a&gt;,
i.e. allow &lt;code&gt;:Japanese&lt;/code&gt;, &lt;code&gt;:Korean&lt;/code&gt; and &lt;code&gt;:Hanb&lt;/code&gt; aliases.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Some characters are not in modern customary use, and thus implementations
may want to exclude them from identifiers.  These include characters in
historic and obsolete scripts, scripts used mostly liturgically, and
regional scripts used only in very small communities or with very limited
current usage.  The set of characters in Table 4, Candidate Characters for
Exclusion from Identifiers provides candidates of these.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;cperl honors the
&lt;a href=&#34;http://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers&#34;&gt;TR31 Candidate Characters for Exclusion from Identifiers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I.e. You may still declare those scripts as valid, but they are not
automatically allowed, similar to the need to declare mixed scripts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8;
my $á­ = 1; # \x{1b45} BALINESE LETTER KAF SASAK

=&amp;gt; Invalid script Balinese in identifier á­ for U+1B45
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but when declared as such:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8 &#39;Balinese&#39;;
my $á­ = 1; # \x{1b45} BALINESE LETTER KAF SASAK
print &amp;quot;ok&amp;quot;;

=&amp;gt; ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The scripts listed at &amp;ldquo;Table 6, Aspirational Use Scripts&amp;rdquo;:
&lt;code&gt;Canadian_Aboriginal&lt;/code&gt;, &lt;code&gt;Miao&lt;/code&gt;, &lt;code&gt;Mongolian&lt;/code&gt;, &lt;code&gt;Tifinagh&lt;/code&gt; and &lt;code&gt;Yi&lt;/code&gt;
are included, i.e. need not to be declared.&lt;/p&gt;

&lt;p&gt;With this restriction we are close to the implementation of the
Moderately Restrictive level for identifiers by default. See
&lt;a href=&#34;http://www.unicode.org/reports/tr39/#General_Security_Profile&#34;&gt;http://www.unicode.org/reports/tr39/#General_Security_Profile&lt;/a&gt; and
&lt;a href=&#34;http://www.unicode.org/reports/tr36/#Security_Levels_and_Alerts&#34;&gt;http://www.unicode.org/reports/tr36/#Security_Levels_and_Alerts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With special declarations of the used scripts you can weaken the
restriction level to &lt;strong&gt;Minimally Restrictive&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Missing for the &lt;strong&gt;Moderately Restrictive&lt;/strong&gt; level are warnings on
single-, mixed and whole-script confusables, and warnings on certain
incompatible mixed-script pairs such as &lt;strong&gt;Greek + Cyrillic&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;All utf8 encoded names are checked for wellformed-ness.&lt;/p&gt;

&lt;h1 id=&#34;comments-at-r-cperl-https-www-reddit-com-r-cperl-comments-5y063u-unicode-identifiers&#34;&gt;&lt;a href=&#34;https://www.reddit.com/r/cperl/comments/5y063u/unicode_identifiers/&#34;&gt;Comments at /r/cperl/&lt;/a&gt;&lt;/h1&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;In Unicode, they&amp;rsquo;re generally unified into a single set, via a process called &amp;ldquo;Han unification&amp;rdquo;. So, unlike Greek &amp;ldquo;Î&amp;rdquo; vs Cyrillic &amp;ldquo;Ð&amp;rdquo;, the &amp;ldquo;same&amp;rdquo; character that may even look slightly differently in Chinese vs Japanese (e.g. &amp;ldquo;æµ·&amp;rdquo;), would have a single codepoint in Unicode.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>cperl hash tables</title>
      <link>http://perl11.org/blog/cperl-hash-tables.html</link>
      <pubDate>Sat, 04 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/cperl-hash-tables.html</guid>
      <description>

&lt;h1 id=&#34;the-old-perl5-hash-table-uses&#34;&gt;The old perl5 hash table uses&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;linked lists for its collisions, with slow out-of-cache pointer
chasing and data overhead.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unsorted flags at the end, while some flags are needed for compare.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;has questionable security measures to slow down all cases. seed ok,
randomize iter maybe, but randomize the collisions and slow hash
funcs is stupid. The security should be fixed with proper collision
iteration, not by pseudo-security theatre upfront.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;no collision search abstraction. The internal implementation quirks
leaked into core and even external modules.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;four different HE types. Only one is needed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;inefficient combination of action flags. many magic hash key lookups
involve internally 3-4 hash lookups.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;was seriously broken 4 times so far.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;in-order-to-clean-up-the-mess-i-did-the-following&#34;&gt;In order to clean up the mess, I did the following&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Added multiple new hash functions, run statistics and evaluated them.
See &lt;a href=&#34;https://github.com/rurban/perl-hash-stats&#34;&gt;perl-hash-stats&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Took over maintainance of the general hash function test suite
&lt;a href=&#34;https://github.com/rurban/smhasher#smhasher&#34;&gt;smhasher&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Attempt to fix the wrong wikipedia entry about hash tables. It
prominently claims that perl5 hash tables are highly optimized, when
in fact they are highly deoptimized, and are in fact the worst and
slowest hash table implementation in existance.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Posted the results to p5p, which was ignored. A few sentences they
said made it clear, that they had no idea what they were
doing. E.g. they made fun of Donald Knuth, and of course of me
&lt;em&gt;(besides calling me an asshole once again)&lt;/em&gt;. Hinting that they
maybe should consult an independent expert sitting in the same
office didn&amp;rsquo;t help. Revising their broken implementation of hash
tables four times so far doesn&amp;rsquo;t improve trust into their abilities.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Started implementing perfect hashes, because they were needed to
speed up all the readonly hashes in core (Config, warnings, unicode
tables).  Found some interesting new results, esp. how to speed
up memcmp by &lt;a href=&#34;http://blogs.perl.org/users/rurban/2014/08/perfect-hashes-and-faster-than-memcmp.html&#34;&gt;50% - 2000%&lt;/a&gt;
with a constant string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Studied hash function and hash table security, and detected a lot of
theatre and wrong practices in most dynamic languages, but
interestingly not in the more technical-orientated important public
services, usually maintained by a single person. Apparently
community driven development in large teams is the worst,
contradicting &lt;a href=&#34;http://www.catb.org/esr/writings/cathedral-bazaar/&#34;&gt;&amp;ldquo;The Cathedral and the Bazaar&amp;rdquo;&lt;/a&gt;. I&amp;rsquo;ll have to seperate that into a new blog post. There are
many more tellsigns of community-based development agony.
Wrote brute-force and solver-based attacks. (&lt;em&gt;No, I&amp;rsquo;m not gonna publish
these&lt;/em&gt;).  So far I could only convince google to revise their
documentation.  Added hashflood testcases to cperl to test detecting
such attacks.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;cperl-hash-tables-use&#34;&gt;cperl hash tables use&lt;/h1&gt;

&lt;p&gt;â a &lt;strong&gt;fast and short hash function&lt;/strong&gt; &lt;a href=&#34;https://github.com/rurban/smhasher#smhasher&#34;&gt;FNV1A&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;â proper DoS and DDoS &lt;strong&gt;security&lt;/strong&gt; by detecting attacks, logging and
  mitigating it. Not using the slowest of all usable hash function
  SipHash, as this doesn&amp;rsquo;t really help against attacks.&lt;/p&gt;

&lt;p&gt;â &lt;code&gt;PERTURB_KEYS_TOP&lt;/code&gt; &lt;strong&gt;move-to-front&lt;/strong&gt; with a linked list is the only
  sane strategy for simple chained bucket lists with many reads.&lt;/p&gt;

&lt;p&gt;â &lt;code&gt;HV_FILL_RATE&lt;/code&gt;: try lower fill rates than 100%.
  100% is pretty insane, esp. with our bad hash funcs. Make it fast with builtin_ctz.
  &lt;a href=&#34;https://github.com/rurban/perl-hash-stats#fill-rates&#34;&gt;&lt;img src=&#34;https://github.com/rurban/perl-hash-stats/raw/master/hash-fillrate-def-FNV1A.png&#34; alt=&#34;FNV1A fill rates&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;â use &lt;code&gt;builtin_ctz&lt;/code&gt; for faster division in &lt;code&gt;DO_HSPLIT&lt;/code&gt;.
  Allow &lt;code&gt;-DHV_FILL_RATE=90&lt;/code&gt; definition. (Tested to be the best with &lt;code&gt;FNV1A&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;â extract uncommon magical code in hot code to an extra static
  function to help keep the icache smaller. only in rare cases this
  branch is taken. (i.e filling ENV at startup). Measured 2-15% faster
  with normal scripts, not using tied hashes.&lt;/p&gt;

&lt;p&gt;â fixed &lt;code&gt;-DNODEFAULT_SHAREKEYS&lt;/code&gt;, preventing every single hash lookup
  to be done twice.  First in strtab, then in the real hash.&lt;/p&gt;

&lt;p&gt;â &lt;strong&gt;pre-extend&lt;/strong&gt; the hash size to the size of the resulting hashes in many cases
  to avoid initialization splits:
  internal stashes of some known packages, internal hashes of some known size,
  fix the hash assign operator to that in user-code.&lt;/p&gt;

&lt;p&gt;and several other minor optimizations. Typically 20% faster than in perl5.&lt;/p&gt;

&lt;h1 id=&#34;cperl-is-working-on-these-improvements&#34;&gt;cperl is working on these improvements:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;abstraction of the abstract &lt;strong&gt;HE_EACH&lt;/strong&gt; collision iterator in the
&lt;a href=&#34;https://github.com/perl11/cperl/commits/feature/gh24-base-hash&#34;&gt;feature/gh24-base-hash&lt;/a&gt; branch &lt;em&gt;(stable)&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;array_he: &lt;strong&gt;abstract AHE&lt;/strong&gt;, inline parts of the HE into the
array. array_he vs ll_he. (linked list, see also the he-array
branch). array_he (&lt;code&gt;HvARRAY = AHE[]&lt;/code&gt;) can contain
&lt;code&gt;{ hent_he, hent_hash }&lt;/code&gt;. This way the hash catches 99% of all comparisons
already, and we don&amp;rsquo;t have to chase the external hek ptr, when the
hash check fails. Every HE entry is then be 2 words (128), instead
of one word (64), called AHE. The linked list still contains the old
&lt;code&gt;HE*&lt;/code&gt;, with &lt;code&gt;{ hent_next, hent_hek, hent_val }&lt;/code&gt;. This is implemented and
works fine in the
&lt;a href=&#34;https://github.com/perl11/cperl/commits/feature/gh24-hash-loop&#34;&gt;featurex/gh24-hash-loop&lt;/a&gt; branch &lt;em&gt;(stable)&lt;/em&gt;, and on top of that the &lt;a href=&#34;https://github.com/perl11/cperl/commits/feature/gh24-array_he&#34;&gt;featurex/gh24-array_he&lt;/a&gt; branch,
which is the base to most other hash tables below.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HE_ARRAY: According to
&lt;a href=&#34;http://goanna.cs.rmit.edu.au/~jz/fulltext/spire05.pdf&#34;&gt;http://goanna.cs.rmit.edu.au/~jz/fulltext/spire05.pdf&lt;/a&gt; the best for
chained hashing is currently a &lt;strong&gt;cache-friendly array of buckets&lt;/strong&gt;,
instead of a linked list. cache-friendly continuous buffer of HE&amp;rsquo;s
w/ inlined HEK (char&lt;em&gt;) + SV&lt;/em&gt; val, but no hash, no next ptr. Also for
shared he&amp;rsquo;s: PL_strtab.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/perl11/cperl/issues/102&#34;&gt;small hash type&lt;/a&gt;:
linear search in embedded array up to 7 keys. ruby, v8 and several
others measured 3-5 to be a big win, esp. for their object fields,
but we don&amp;rsquo;t even have that yet. avoid the hash init, calc and search
overhead, esp. with our overly slow hash tables.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;hash-sortbuckets: a sorted static list of collisions (up to 8, maybe
start with 3, then 8) as in the Knuth &lt;strong&gt;&amp;ldquo;ordered hash table&amp;rdquo;&lt;/strong&gt;. We will not
use that.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;khash&lt;/strong&gt;: use open addressing as everyone else. faster, less space. But
khash needs a few fixes. And we can not use that, as perl5 is not properly
abstracted to be able to use external hash tables.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;one-word-AHE&lt;/strong&gt;: As possible improvement on that on 64bit use 48bits
for the HE ptr, and 16bits of the hash to be compared first. See
&lt;a href=&#34;https://www.semanticscholar.org/paper/Fast-Dynamically-Sized-Concurrent-Hash-Table-Barnat-Rockai/ab7dd007587f411cf99bfe056639e055eff22e0c/pdf&#34;&gt;https://www.semanticscholar.org/paper/Fast-Dynamically-Sized-Concurrent-Hash-Table-Barnat-Rockai/ab7dd007587f411cf99bfe056639e055eff22e0c/pdf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;use &lt;strong&gt;robin-hood&lt;/strong&gt; as this is currently the best worse-case strategy
(being super defensive, but not so stupid to use SipHash, which adds
no benefit). With better native threading support (shared hashes)
eventually use &lt;strong&gt;leapfrog&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;compact ordered hash&lt;/strong&gt;. use an array of short indices into a compacted
array of hash/key/val entries as in PyPy and now python: &amp;ldquo;compact
ordered dict&amp;rdquo;. This saves a lot of space and only add&amp;rsquo;s one indirect
lookup into cache-friendly array. See methane/cpython#1
&lt;a href=&#34;https://mail.python.org/pipermail/python-dev/2016-September/146327.html&#34;&gt;https://mail.python.org/pipermail/python-dev/2016-September/146327.html&lt;/a&gt;
This also iterates over the hash in insertion order, which
effectively hides any attempt to get the seed over the
iterators. For attacks you need to get collision and robin-hood
reordering timings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;get rid of &lt;strong&gt;HEK_WASUTF8&lt;/strong&gt;. &amp;ldquo;There shall be only one state, not
two&amp;rdquo;. Rather fix the encoding bug (CPAN) instead.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;p5p-plans&#34;&gt;p5p plans&lt;/h1&gt;

&lt;p&gt;p5p announced that it is working on switching to an abstract vtable
for hash tables, which is similar to their idea to run-time switch
hash functions truly horrendous.  They say it is needed to abstract
readonly (i.e. perfect hashes), and maybe tied and restricted
hashes.&lt;/p&gt;

&lt;p&gt;The cost of this would be another indirection in every hash
table call, and I don&amp;rsquo;t see any benefit.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t see a cleanup of the monstrous implementation and different
types and attempts to actually improve any of the problematic issues.
As usual with p5p it will make the situation even worse, not better.&lt;/p&gt;

&lt;h1 id=&#34;conflicts&#34;&gt;Conflicts&lt;/h1&gt;

&lt;p&gt;Having worked with &lt;code&gt;PERTURB_KEYS_TOP&lt;/code&gt; move-to-front in cperl for a few
years now, there&amp;rsquo;s only one broken module Text::CVS_XS, which assumes
in one of its testcases for parse without headers that the ordering of
keys is stable when the size did not change. The fix is in my
&lt;a href=&#34;https://github.com/rurban/distroprefs/blob/master/sources/authors/id/R/RU/RURBAN/patches/Text-CSV_XS-cperl.patch&#34;&gt;distroprefs&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-5xofay-cperl-hash-tables&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/5xofay/cperl_hash_tables/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Worst perl5 bugs</title>
      <link>http://perl11.org/blog/worst-perl5-bugs.html</link>
      <pubDate>Mon, 30 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/worst-perl5-bugs.html</guid>
      <description>

&lt;h1 id=&#34;a-small-list-of-the-worst-perl5-bugs-all-fixed-in-cperl&#34;&gt;A small list of the worst perl5 bugs, all fixed in cperl&lt;/h1&gt;

&lt;h1 id=&#34;dos&#34;&gt;DoS&lt;/h1&gt;

&lt;p&gt;It&amp;rsquo;s trivial to DoS a perl5 system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a[9223372036854]=0;
%a=(0..4294967296);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Examples for a 64bit system, but also trivial on 32bit.
It creates a huge array or hash, which runs out of memory in the VMM
subsystem which eventually kills the process.
cperl dies with &amp;ldquo;Too many elements&amp;rdquo;, here even at compile-time.&lt;/p&gt;

&lt;h1 id=&#34;no-hash-security&#34;&gt;No Hash Security&lt;/h1&gt;

&lt;p&gt;Nothing is done against the root-cause of a hash flood denial of
service attack with colliding keys, only some security theatre by
using slower hash functions and slower collision resolution
&lt;code&gt;KEY_PERTURB_RANDOM&lt;/code&gt;.  If the seed is exposed, trivially on perl5 as
it is at a fixed known address offset readable via unpack, or exposed
via the command line, there is no prevention. Only cperl is secure,
and also much faster.  See e.g. &lt;a href=&#34;https://github.com/perl11/cperl/blob/master/t/op/hashflood.t&#34;&gt;cperl &lt;code&gt;t/op/hashflood.t&lt;/code&gt;&lt;/a&gt;
Or &lt;a href=&#34;http://perl11.org/cperl/perl5241cdelta.html#Protect-and-warn-on-hash-flood-DoS&#34;&gt;perl5241cdelta/&amp;ldquo;Protect and warn on hash flood DoS&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PERL_HASH_SEED_DEBUG=1 perl -e1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pointing that out on p5p led to the developer simply ignoring it. Instead they
are working on making it even slower, but not improving the horrible implementation
and security.&lt;/p&gt;

&lt;h1 id=&#34;language-maintainance&#34;&gt;Language Maintainance&lt;/h1&gt;

&lt;h2 id=&#34;silent-integer-overwraps&#34;&gt;Silent integer overwraps&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;@a=(0,1); print $a[~1] =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;~1&lt;/code&gt; is essentially &lt;code&gt;(UV)-2&lt;/code&gt; or &lt;code&gt;0xffff_fffe&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@a=(1);print $a[18446744073709551615]&#39; =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Silent overwrap of 18446744073709551615 to -1.&lt;/p&gt;

&lt;p&gt;The same happens with overlong hash keys, they are not converted to
SVs which can hold overlong strings. Everything in the buffer after
I32 s ignored.  Or with overlong hashes, where you can create huge hashes
&amp;gt;I32 but can only iterate over the first I32 entries.&lt;/p&gt;

&lt;p&gt;With cperl the &amp;ldquo;Too many elements&amp;rdquo; error is now triggered when
accessing or extending an out of bounds array index or trying to
insert too many hash keys. This is to prevent from silent hash or
array overflows. Previously extending a hash beyond it&amp;rsquo;s capable size
was silently ignored, leading to performance degradation with overly
high fill factors and extending an array failed only on memory
exhaustion, but the signed index led to an index overflow between I32
and U32, resp.  I64 and U64.&lt;/p&gt;

&lt;p&gt;Even worse, accessing overflown unsigned array indices would silently
access the signed counterpart, indices at the end.&lt;/p&gt;

&lt;p&gt;chop/chomp only works on half of overlarge arrays.&lt;/p&gt;

&lt;p&gt;Or ~&amp;ldquo;a&amp;rdquo;x2G complement of overlarge strings, silently processing only
the half - as with overlong hash keys.&lt;/p&gt;

&lt;p&gt;There was also a smartmatch Array - CodeRef rule, which passed only over
half the array elements.  The Hash part was also wrong, but the wrong number
was not used.&lt;/p&gt;

&lt;p&gt;regex match group of &amp;gt;2GB string len.&lt;/p&gt;

&lt;p&gt;repeat count &amp;gt;2GB and don&amp;rsquo;t silently cap it at IV_MAX. Which was
at least better then silent wrap around.&lt;/p&gt;

&lt;h1 id=&#34;names&#34;&gt;Names&lt;/h1&gt;

&lt;h2 id=&#34;binary-names&#34;&gt;Binary names&lt;/h2&gt;

&lt;p&gt;Only cperl is binary safe against \0 in names, which is esp. unsafe with
package names, being mapped 1:1 to filenames.&lt;/p&gt;

&lt;h2 id=&#34;insecure-unicode-names&#34;&gt;Insecure unicode names&lt;/h2&gt;

&lt;p&gt;Unicode allows to be identifiers not identifiable, i.e. confusable
evading visual inspection of 3rd party code. Bidi spoofs can contain
right-to-left overwriting L-T-R characters, combining marks, mixed
scripts (e.g. Cyrillic and Greek), &amp;hellip;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a TR39 security guideline for identifiers which &lt;a href=&#34;http://perl11.org/cperl/perl5252cdelta.html#Security&#34;&gt;cperl implements&lt;/a&gt;.
perl5 has no idea about that and is not willing to fix it, even if perlcc
prominently warns about that since 5.16.&lt;/p&gt;

&lt;p&gt;No &lt;a href=&#34;http://perl11.org/cperl/perl5240cdelta.html#Security&#34;&gt;Unicode confusables +UFFA0, +U3164&lt;/a&gt;. In deviation from Unicode 1.1
we treat the two HANGUL FILLER characters +UFFA0 and +U3164 not as
valid ID_Start and ID_Continue characters for perl identifiers.&lt;/p&gt;

&lt;h2 id=&#34;overlong-names&#34;&gt;overlong names&lt;/h2&gt;

&lt;p&gt;The &amp;ldquo;panic: hash key too long&amp;rdquo; error is now thrown with overlarge hash keys in every
&lt;code&gt;hv_common&lt;/code&gt; access and in Cpanel::JSON::XS.
perl5 still silently ignores those failures, and truncates the keys.&lt;/p&gt;

&lt;p&gt;Many more similar &amp;ldquo;panic: (file|keyword|mro|stash)? name too long&amp;rdquo; errors
were added to the parser and compiler to protect from overlong names
(&amp;gt; I32_MAX, 2147483647).&lt;/p&gt;

&lt;h2 id=&#34;insecure-taint-mode&#34;&gt;Insecure taint mode&lt;/h2&gt;

&lt;p&gt;perl5 has several known taint loopholes, see &lt;a href=&#34;http://perl11.org/cperl/perlsec.html#Taint-mode&#34;&gt;perlsec&lt;/a&gt;. cperl has them all fixed.&lt;/p&gt;

&lt;p&gt;Of course it is much faster to use tainted variables, as you don&amp;rsquo;t have to
check and sanitize every single variable, only external, tainted ones.&lt;/p&gt;

&lt;h1 id=&#34;minor-issues-from-perl540cdelta-http-perl11-org-cperl-perl5240cdelta-html-security&#34;&gt;Minor issues from &lt;a href=&#34;http://perl11.org/cperl/perl5240cdelta.html#Security&#34;&gt;perl540cdelta&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&#34;dynaloader-format-string-hardening&#34;&gt;DynaLoader format string hardening&lt;/h2&gt;

&lt;p&gt;Replace all &lt;code&gt;%&lt;/code&gt; characters in user-controlled library filenames, passed via
the system dl_error call verbatim to &lt;code&gt;printf&lt;/code&gt;, without any arguments on the stack,
which could lead to execution of arbitrary stack code. No CVE.
This affects all systems with dynamic loading where the attacker can cause a
dynamic loading error.&lt;/p&gt;

&lt;p&gt;CVSSv2 Severity: 7.2
(AV:L/AC:L/Au:N/C:C/I:C/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:H/IR:H/AR:ND)&lt;/p&gt;

&lt;h2 id=&#34;xsloader-relative-paths-with-eval-or-line&#34;&gt;XSLoader relative paths with eval or #line&lt;/h2&gt;

&lt;p&gt;Upstream XSLoader 0.22 (perl 5.26) fixed a minor security problem with
XSLoader within eval or with a #line directive, which can load a local
relative shared library, which is not in &lt;code&gt;@INC&lt;/code&gt;.
See &lt;a href=&#34;https://rt.cpan.org/Ticket/Display.html?id=115808&#34;&gt;https://rt.cpan.org/Ticket/Display.html?id=115808&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;cperl XSLoader was already protected against the eval case since 5.22,
when being rewritten in C. cperl-5.24.0 fixed now also ignoring a relative
filename in a &lt;code&gt;#line&lt;/code&gt; directive, when the relative path is not in &lt;code&gt;@INC&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;handle-method-calls-on-protected-stashes&#34;&gt;handle method calls on protected stashes&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/perl11/cperl/issues/171&#34;&gt;https://github.com/perl11/cperl/issues/171&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Known bug upstream, not fixed there. This problem appears more often
with cperl with its protected coretypes than upstream.&lt;/p&gt;

&lt;h2 id=&#34;fedora-do-not-crash-when-inserting-a-non-stash-into-a-stash&#34;&gt;fedora: Do not crash when inserting a non-stash into a stash&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128238&#34;&gt;Fedora Patch 37 RT#128238&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fedora-do-not-treat-as-a-stash&#34;&gt;fedora: Do not treat %: as a stash&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128238&#34;&gt;Fedora Patch36 RT#128238&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fedora-fix-precedence-in-hv-ename-delete&#34;&gt;fedora: Fix precedence in hv_ename_delete&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128086&#34;&gt;Fedora Patch35 RT#128086&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fedora-do-not-use-unitialized-memory-in-h-const-warnings&#34;&gt;fedora: Do not use unitialized memory in $h{\const} warnings&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128189&#34;&gt;Fedora Patch34 RT#128189&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fedora-do-not-mangle-errno-from-failed-socket-calls&#34;&gt;fedora: Do not mangle errno from failed socket calls&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128316&#34;&gt;Fedora Patch32 RT#128316&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fedora-backport-memory-leak-when-compiling-a-regular-expression-with-a-posix-class&#34;&gt;fedora: Backport memory leak when compiling a regular expression with a POSIX class&lt;/h2&gt;

&lt;p&gt;E.g. when C&lt;use re &#39;strict&#39;;&gt; is used.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128313&#34;&gt;Fedora Patch31 RT#128313&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;suse-perl5-24-0-dif&#34;&gt;suse: perl5.24.0.dif&lt;/h2&gt;

&lt;p&gt;Many Configure and linux hints enhancements, esp for lib64,
probe fixes, gdbm and ODBM fixes, gnu readline integration with the debugger.
See &lt;a href=&#34;https://build.opensuse.org/package/show/devel:languages:perl/perl&#34;&gt;https://build.opensuse.org/package/show/devel:languages:perl/perl&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;suse-fix-regexp-backref-overflows&#34;&gt;suse: fix regexp backref overflows&lt;/h2&gt;

&lt;p&gt;With many backref groups (&amp;gt;I32)&lt;/p&gt;

&lt;h2 id=&#34;suse-perl-saverecontext-diff-rt-76538&#34;&gt;suse: perl-saverecontext.diff RT#76538&lt;/h2&gt;

&lt;p&gt;Handle get magic with globs in the regex compiler.
Correctly restore context, esp. when loading unicode swashes.
Reported at 5.12, patched for suse 5.14, still ignored with 5.24.&lt;/p&gt;

&lt;h1 id=&#34;minor-issues-from-perl541cdelta-http-perl11-org-cperl-perl5241cdelta-html-security&#34;&gt;Minor issues from &lt;a href=&#34;http://perl11.org/cperl/perl5241cdelta.html#Security&#34;&gt;perl541cdelta&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&#34;warn-on-metasploit-cve-2015-1592&#34;&gt;Warn on metasploit CVE-2015-1592&lt;/h2&gt;

&lt;p&gt;There are known and exploitable attack vectors published for years,
and there&amp;rsquo;s no effort to even detect or warn about it.&lt;/p&gt;

&lt;p&gt;cperl detects of the destructive attack against Movable-Type, the third
vector only, which tries to delete &lt;code&gt;mt-config.cgi&lt;/code&gt; was added to was
added to cperl &lt;code&gt;Storable&lt;/code&gt; 3.01c.&lt;/p&gt;

&lt;p&gt;Warns with &amp;ldquo;SECURITY: Movable-Type CVE-2015-1592 Storable metasploit attack&amp;rdquo;
but does not protect against it.&lt;/p&gt;

&lt;h2 id=&#34;warn-on-metasploit-reverse-shells&#34;&gt;Warn on metasploit reverse shells&lt;/h2&gt;

&lt;p&gt;cperl detects the metasploit payload unix/reverse_perl and some existing
variants.  This is just a dumb match at startup against existing
exploits in the wild, but not future variants.  Warns with
&amp;ldquo;SECURITY: metasploit reverse/bind shell payload&amp;rdquo;, but do not
protect against it. This warning is thrown even without C&amp;lt;-w&amp;gt;.&lt;/p&gt;

&lt;p&gt;Also detects the CVE-2012-1823 reverse/bind shell payload, which is
widely exploited too. The security warning is called
&amp;ldquo;SECURITY: CVE-2012-1823 reverse/bind shell payload&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;fixed-overwriting-the-hvhek-unshared-bit-in-the-hash-loop&#34;&gt;Fixed overwriting the HVhek_UNSHARED bit in the hash loop&lt;/h2&gt;

&lt;p&gt;Broken with v5.9&lt;/p&gt;

&lt;p&gt;This fixed &lt;code&gt;-DNODEFAULT_SHAREKEYS&lt;/code&gt;. In the default configuration
without &lt;code&gt;NODEFAULT_SHAREKEYS&lt;/code&gt; since 5.003_001 all hash keys are stored
twice, once in the hash and once again in &lt;code&gt;PL_strtab&lt;/code&gt;, the global
string table, with the benefit of faster hash loops and copies. Almost
all hashtables get the SHAREKEYS bit.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;-Accflags=-DNODEFAULT_SHAREKEYS&lt;/code&gt; simple scripts are 20-30%
faster.  &lt;a href=&#34;https://github.com/perl11/cperl/issues/201&#34;&gt;https://github.com/perl11/cperl/issues/201&lt;/a&gt; but practical
usage is dominated by copying hashes, which is faster with shared
keys.&lt;/p&gt;

&lt;h2 id=&#34;dfortify-inc&#34;&gt;-Dfortify_inc&lt;/h2&gt;

&lt;p&gt;A security problem.  Was in the very first cperl release 5.22.1,
because we detected it and developed the fixes. With full toolchain
support, in all modules. perl5 caught up 2 years later, 5.26.  But of
course they changed the established name to their own
&lt;code&gt;-Ddefault_inc_excludes_dot&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;perl4-package-seperator&#34;&gt;perl4 &amp;lsquo; package seperator&lt;/h2&gt;

&lt;p&gt;cperl deleted that, and fixed all issues.&lt;/p&gt;

&lt;h1 id=&#34;unicode-bugs&#34;&gt;unicode bugs&lt;/h1&gt;

&lt;p&gt;e.g range is broken in perl5, fixed in cperl 5.24.1c.
Apparently fixed with 5.26 finally.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $r = chr 255; utf8::upgrade $r; my $num = (&amp;quot;a&amp;quot; .. $r);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;utf8-padnames&#34;&gt;utf8 padnames&lt;/h2&gt;

&lt;p&gt;In perl5 all padnames are utf8 encoded by default. In cperl only those
who are utf8 encoded. &lt;a href=&#34;https://github.com/perl11/cperl/issues/208&#34;&gt;https://github.com/perl11/cperl/issues/208&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;compiler-toolchain-support&#34;&gt;compiler toolchain support&lt;/h2&gt;

&lt;p&gt;perl5 links with CC and ignores the linker LD, which disables advanced
llvm thin, lto and cfe support. e.g. clang-4 is produces 20% faster
code, and with cfe much safer code.&lt;/p&gt;

&lt;p&gt;perl5 is inable to produce reproducible builds. cperl does it by default.&lt;/p&gt;

&lt;h2 id=&#34;lexical-support&#34;&gt;lexical $_ support&lt;/h2&gt;

&lt;p&gt;perl5 was not able to find and fix the trivial bugs.
Their core features and modules rely on that, but they removed it.
esp. given/when, smartmatch, List::Utils.
cperl supports it.&lt;/p&gt;

&lt;h2 id=&#34;use-encoding&#34;&gt;use encoding&lt;/h2&gt;

&lt;p&gt;perl5 was not able to find and fix the trivial bugs. Many foreign devs
rely on that, but they removed it.  cperl supports it.&lt;/p&gt;

&lt;h2 id=&#34;pl-maxo&#34;&gt;PL_maxo&lt;/h2&gt;

&lt;p&gt;perl5 removed it, while it is necessary to track custom ops.
cperl supports it.&lt;/p&gt;

&lt;h2 id=&#34;for-qw&#34;&gt;for qw(&amp;hellip;)&lt;/h2&gt;

&lt;p&gt;perl5 removed support &lt;code&gt;for qw()&lt;/code&gt; with bogus justification. You need to write
&lt;code&gt;for (qw(..)) {}&lt;/code&gt;
The promised parser improvements never arrived.&lt;/p&gt;

&lt;p&gt;cperl allows &lt;code&gt;for qw(...)&lt;/code&gt; and supporting it is trivial.&lt;/p&gt;

&lt;h2 id=&#34;pmc-loading-and-reflection&#34;&gt;.pmc loading and reflection&lt;/h2&gt;

&lt;p&gt;perl5 removed timestamp checks for pugs with 5.8, a module doesn&amp;rsquo;t
know if it&amp;rsquo;s loaded from a &lt;code&gt;.pmc&lt;/code&gt;, and force loading a &lt;code&gt;.pm&lt;/code&gt; is not
possible.&lt;/p&gt;

&lt;p&gt;cperl fixed that for the upcoming JitCache support, which adds
expensively optimized subs for a package to a &lt;code&gt;.pmc&lt;/code&gt;. But only some, not
all subs.  So a &lt;code&gt;.pmc&lt;/code&gt; can never replace a full &lt;code&gt;.pm&lt;/code&gt;. So reflection and
loading &lt;code&gt;.pm&lt;/code&gt; needs to be enabled.&lt;/p&gt;

&lt;h1 id=&#34;core-modules&#34;&gt;Core modules&lt;/h1&gt;

&lt;h2 id=&#34;storable&#34;&gt;Storable&lt;/h2&gt;

&lt;p&gt;The CPAN version was never updated.  The core version suffers from
several severe core bugs, similar to the inability in core to support
huge &amp;gt;2GB data.&lt;/p&gt;

&lt;p&gt;cperl Storable fixes JD&amp;rsquo;s stack-overflow write (totally a CVE),
detects the known MetaSploit attack vector and supports large objects,
strings, hashed and arrays.&lt;/p&gt;

&lt;p&gt;There are also more stack-overflow attacks fixed in my CPAN version.&lt;/p&gt;

&lt;h2 id=&#34;yaml&#34;&gt;YAML&lt;/h2&gt;

&lt;p&gt;YAML is slow, incompatible with itself and insecure by default.&lt;/p&gt;

&lt;p&gt;e.g. Parse-CPAN-Meta security: cperl is 10x faster, can read its own files
and sets &lt;code&gt;$YAML::XS::DisableCode&lt;/code&gt;, &lt;code&gt;$YAML::XS::DisableBlessed&lt;/code&gt; while
parsing &lt;code&gt;META.yml&lt;/code&gt; or CPAN &lt;code&gt;.yml&lt;/code&gt; files.&lt;/p&gt;

&lt;p&gt;Very similar to Storable. At least with YAML the upstream maintainer is listening,
but he needs &amp;gt;1 year to merge my fixes, which is not acceptable. Nothing published
yet upstream. Needs to be &lt;a href=&#34;https://github.com/perl11/cperl/issues/198&#34;&gt;forked&lt;/a&gt; eventually.&lt;/p&gt;

&lt;h2 id=&#34;json-xs&#34;&gt;JSON::XS&lt;/h2&gt;

&lt;p&gt;Look at the relevant pod section in &lt;a href=&#34;http://search.cpan.org/dist/Cpanel-JSON-XS/XS.pm#SECURITY_CONSIDERATIONS&#34;&gt;Cpanel::JSON::XS&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;For the security bugs see on cperl:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -A20 &#39;=head1 Security&#39; pod/perl*cdelta.pod
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-5xof8j-worst-perl5-bugs&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/5xof8j/worst_perl5_bugs/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>p5p incompetence</title>
      <link>http://perl11.org/blog/p5p-incompetence.html</link>
      <pubDate>Tue, 24 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/p5p-incompetence.html</guid>
      <description>

&lt;p&gt;So I was continously asked to explain why I call p5p too incompetent to
design anything for the perl5 language and any internal VM features.&lt;/p&gt;

&lt;p&gt;So far I was reluctant to do so, because users will be as emberrassed as I
am, and need a way to got forward. Now that I can offer a way forward it
might be easier to publish the detailed criticsm on p5p&amp;rsquo;s incompetence.&lt;/p&gt;

&lt;p&gt;From a high level view it&amp;rsquo;s pretty easy to prove.  p5p, the perl5
porters was originally a mailing list to help Larry Wall, the language
creator to maintain ports to other platforms. like solaris, hpux,
irix, os/2, windows and so on. That&amp;rsquo;s why it&amp;rsquo;s called porters, and not
perl5-dev, perl5-lang or something.
Then, when Larry Wall stopped maintaining perl5 and went on to perl6, p5p
took over maintainance of perl5 from him.
Let&amp;rsquo;s roughly say p5p started 2001 and hopefully will be freed from maintaining
the language and the vm 2016, 15 years.&lt;/p&gt;

&lt;p&gt;In these 15 years p5p did almost nothing good, and a lot of things very bad.&lt;/p&gt;

&lt;h1 id=&#34;let-s-start-with-the-good-things&#34;&gt;let&amp;rsquo;s start with the good things:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;lang:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;adoption of perl6 &lt;code&gt;say&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;design and implementation of dor &lt;code&gt;//&lt;/code&gt; (defined-or)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;vm:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;direct access to sv bodies, and sv arenas&lt;/li&gt;
&lt;li&gt;op arenas&lt;/li&gt;
&lt;li&gt;multideref&lt;/li&gt;
&lt;li&gt;cleanup of CX, the context stack&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;say is trivial, but with proper 5.005 threads even then wrong, as was
seen in parrot.&lt;/p&gt;

&lt;p&gt;defined-or is trivial, but the discussion about the syntax was so
painful, that Tom Christianson left p5p over that, which got Larry
very angry. and &amp;lsquo;//&amp;rsquo; for defined-or and not something with matching is
also very ill-designed. That&amp;rsquo;s the only new syntax since decades.&lt;/p&gt;

&lt;p&gt;The 5.10 rearchitecture by one person was still 10% slower than 5.8.9,
(only startup time got faster)
And broke many important internal B modules, like the compiler, the
type checkers and optimizers, B::Generate, &amp;hellip;&lt;/p&gt;

&lt;p&gt;The rest was great work, esp. the context cleanup.&lt;/p&gt;

&lt;h1 id=&#34;neutral&#34;&gt;neutral:&lt;/h1&gt;

&lt;h2 id=&#34;proper-implementation-of-given-when-and-smartmatch-from-perl6&#34;&gt;proper implementation of given/when and smartmatch from perl6&lt;/h2&gt;

&lt;p&gt;given/when was plagued by an initial bug in the optimization of lexical &lt;code&gt;$_&lt;/code&gt;
2001, mixing up a bitcheck, which initially worked by chance, but was later
broken in op redesign. They never found the bug, and decided mark it as
&amp;lsquo;experimental&amp;rsquo;, i.e. broken.
Now without working lexical &lt;code&gt;$_&lt;/code&gt; it is doomed. A run-time matcher makes not much
sense. What it needs are compile-time optimizations. Most matches can already
perform before.&lt;/p&gt;

&lt;p&gt;smartmatch was always plagued by the lack of coretypes and the subsequent
over-architecturing of the possible lhs-rhs match combinations.
without working lexical &lt;code&gt;$_&lt;/code&gt; it is also doomed.&lt;/p&gt;

&lt;p&gt;Note that p5p didn&amp;rsquo;t implement given/when and smartmatch, it came from
outside.  That&amp;rsquo;s why they have so many problems to maintain it.&lt;/p&gt;

&lt;h1 id=&#34;bad&#34;&gt;bad:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;removed automatic compile-time optimizations in constant-folder&lt;/li&gt;
&lt;li&gt;no adoption of the initially designed type system&lt;/li&gt;
&lt;li&gt;no object system: no class/method, use oo :final, multi-dispatch, method-combinations&lt;/li&gt;
&lt;li&gt;incompetence maintaining pseudo-hashes&lt;/li&gt;
&lt;li&gt;horrible over-architecturing everything damian conway did&lt;/li&gt;
&lt;li&gt;horrible implementation of switch, based on source filters&lt;/li&gt;
&lt;li&gt;incompetence maintaining native threads (5005threads)&lt;/li&gt;
&lt;li&gt;incompetence maintaining the compiler&lt;/li&gt;
&lt;li&gt;incompetence maintaining B&lt;/li&gt;
&lt;li&gt;lack of understanding of basic data types

&lt;ul&gt;
&lt;li&gt;scalar&lt;/li&gt;
&lt;li&gt;array&lt;/li&gt;
&lt;li&gt;hash&lt;/li&gt;
&lt;li&gt;regex&lt;/li&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;li&gt;methods&lt;/li&gt;
&lt;li&gt;symbols&lt;/li&gt;
&lt;li&gt;binary symbols and names&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;lack of understanding of basic vm techniques&lt;/li&gt;
&lt;li&gt;no plan&lt;/li&gt;
&lt;li&gt;signatures&lt;/li&gt;
&lt;li&gt;modules&lt;/li&gt;
&lt;li&gt;death by code of conduct&lt;/li&gt;
&lt;li&gt;security&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;in-detail&#34;&gt;In detail:&lt;/h1&gt;

&lt;h2 id=&#34;removed-automatic-compile-time-op-optimizations-in-constant-folder&#34;&gt;removed automatic compile-time op optimizations in constant-folder&lt;/h2&gt;

&lt;p&gt;One special guy with big personality problems removed that by himself,
against the explicit analysis of the community.
Now perl5 has the semantic problem that obvious constant values cannot
be treated as constants. cperl fixed that by going back to the pre-p5p semantics
(5.005), but that&amp;rsquo;s the only major mismatch. It is only a problem with integer
overflows.&lt;/p&gt;

&lt;h2 id=&#34;no-adoption-of-the-initially-designed-type-system&#34;&gt;no adoption of the initially designed type system&lt;/h2&gt;

&lt;p&gt;perl6 has one, cperl has one, everyone is happy, just p5p bitches
about it. &amp;ldquo;Only over our dead bodies.&amp;rdquo;
Now after a few years even all other dynamic languages implemented it
only p5p is still clueless.&lt;/p&gt;

&lt;h2 id=&#34;no-adoption-of-class-method-use-oo-final-multi-dispatch&#34;&gt;no adoption of class/method, use oo :final, multi-dispatch&lt;/h2&gt;

&lt;p&gt;perl5 has an extremely slow OO system, without any features.  It can
be extended, but then it&amp;rsquo;s even 10x slower. There&amp;rsquo;s no internal
support for the needed features. Those features were designed 15 years
ago, so there&amp;rsquo;s no need for external experimentation.  Moose is a
horrible abomination of those features and syntax. Spiffy, Mouse or
Dios do come closer but it&amp;rsquo;s still a long stretch to a useful OO
system.&lt;/p&gt;

&lt;p&gt;Everybody is talking about the need of a MOP, but nobody knows what a
OO vs MOP is. What is needed is an OO with introspection, but not a
MOP. What is needed is a way to make field access and dispatch
performant, and finalization.&lt;/p&gt;

&lt;h2 id=&#34;incompetence-maintaining-pseudo-hashes&#34;&gt;incompetence maintaining pseudo-hashes&lt;/h2&gt;

&lt;p&gt;The current narrative is that is was an enourmous failure, and
completely wrong.  The failure was one little part during
implemention, when one innocent guy stepped up and said, why cannot we
have support for this (tie) also? And then this was supported also,
and then performance and design went downhill. If you ask p5p, they
have no idea what went wrong and why. The party line is that the
whole idea was a desaster, not just their maintainance failure along
the line.&lt;/p&gt;

&lt;p&gt;pseudo-hashes were a neat trick to support compile-time plus run-time
fields in an efficient and introspective way. Of course in the
non-perl world the compiler should have changed hash-like access of
compile-time known members to linear lookup in array fields, and not
expose the hashes as pseduo-hashes to the user at all. Run-time
computed fields would still use a hash table as in a cache or linear
search through the fields. &lt;code&gt;$obj-&amp;gt;field&lt;/code&gt; vs &lt;code&gt;$obj-&amp;gt;$field&lt;/code&gt; as in
method dispatch or &lt;code&gt;$obj-&amp;gt;{field}&lt;/code&gt; vs &lt;code&gt;$obj-&amp;gt;{$field}&lt;/code&gt;. perl6
thanksfull got away with the latter hash syntax and exposes all its
fields as members in a method-like syntax. And there are syntactic
designators for visibility and read/write accessors. This way the user
cannot create clashes between methods and fields as all fields are
exposed as methods, and the compilers knows what is what.&lt;/p&gt;

&lt;p&gt;Marc Jason Dominus explains at the &lt;a href=&#34;https://www.youtube.com/watch?v=-HlGQtAuZuY&#34;&gt;Pittburgh Perl Workshp 2014&lt;/a&gt;
how the perl community is not able to understand it why their attempt
to maintain this feature utterly failed. &amp;ldquo;A new, never-before-seen
talk on Perl&amp;rsquo;s catastrophic experiment with âpseudohashesâ, which
wasted everyone&amp;rsquo;s time for nine years between 1998 and 2007.&amp;rdquo; His
words, not mine.&lt;/p&gt;

&lt;h2 id=&#34;horrible-over-architecturing-everything-damian-conway-did&#34;&gt;horrible over-architecturing everything damian conway did&lt;/h2&gt;

&lt;p&gt;Thanksfully not much of him is in core.&lt;/p&gt;

&lt;p&gt;Attributes are unusable because of him, the implementation is not as bad as
a usual conway implementation (good in theory, but naive and impractical),
even all the documentation improvement attempts were rejected by p5p.  The
fast XS implementation was replaced by a worse and slower PP implemantation,
Attribute::Handlers which is in core, is insecure by default, it evals all
its attribute values. e.g. with &lt;code&gt;App::Rad&lt;/code&gt;
&lt;code&gt;sub unlink :Help(unlink &amp;quot;a/file&amp;quot;);&lt;/code&gt; as documentation
attribute will call &lt;code&gt;unlink &amp;quot;a/file&amp;quot;&lt;/code&gt; at compile-time.&lt;/p&gt;

&lt;h2 id=&#34;horrible-implementation-of-switch-based-on-source-filters&#34;&gt;horrible implementation of switch, based on source filters&lt;/h2&gt;

&lt;p&gt;This Filter hack is still in core.&lt;/p&gt;

&lt;h2 id=&#34;incompetence-maintaining-native-threads&#34;&gt;incompetence maintaining native threads&lt;/h2&gt;

&lt;p&gt;Agreed, using 5005threads requires knowledge of concurrency, needs locking
in many XS extensions and esp. a concurrent hash table.  This was not state
of the art those times.&lt;/p&gt;

&lt;p&gt;But the pseudo threads (ithreads) should not have been called threads.
there&amp;rsquo;s no proper COW support, all the data needs to be be cloned to each
new thread, so you got a huge initialization hit. And the run-time supports
no ownership or capabilities, so all the data needs to linked back and forth
manually.&lt;/p&gt;

&lt;p&gt;Forking does this properly, so you need to use fork. ithreads are only an
overly slow fork emulation for windows.&lt;/p&gt;

&lt;h2 id=&#34;incompetence-maintaining-the-compiler&#34;&gt;incompetence maintaining the compiler&lt;/h2&gt;

&lt;p&gt;With the data layout changes for 5.10 they removed all the compilers, and
dropped support for basically all compile-time extensions with its B module
hierarchy, the introspection framework.
All the type checkers, optimizers, compilers were gone.
All the people working on compile-time optimizations left to better languages.&lt;/p&gt;

&lt;p&gt;It is surprising because the three B compilers are much simplier to understand
and to maintain than the core VM.  But it is not so surprising when you
realize that they have also no idea how the VM works and should work.
All the people you have an idea went on, or switched to perl6, were the most
egregious perl5 design mistakes were solved.&lt;/p&gt;

&lt;h2 id=&#34;incompetence-maintaining-b&#34;&gt;incompetence maintaining B&lt;/h2&gt;

&lt;p&gt;Since the B instrospection module needs to able to represent all the
internal core data structures to pure-perl users, but only the simpliest B
modules were left intact with the 5.10 axe, it&amp;rsquo;s hardly surprising that B
started bitrotting. nobody cared anymore, it was only used for the
B::Deparse toy, which never worked 100%, and B::Concise, a simple display of
the ops.&lt;/p&gt;

&lt;p&gt;The destruction happened gradually, but the real problem was that eventual
breakage was not undone, with the argumention that &amp;ldquo;p5p does not understand
how this works, and how we broke it.  go away&amp;rdquo;.  They outright refused to
fix it for years and it is still broken.  I have to maintain my own version
of B, which you need for any compiler.&lt;/p&gt;

&lt;h2 id=&#34;lack-of-understanding-of-basic-data-types&#34;&gt;lack of understanding of basic data types&lt;/h2&gt;

&lt;p&gt;perl5 lacks the most basic performance features of all the existing data
types. This were mostly Larry Wall mistakes, and he could have looked up how
other languages did it those times.&lt;/p&gt;

&lt;p&gt;My point here is that even after 20 years nobody within perl5 has any idea
how to improve it, even if now everybody else found put. Even php7 put perl5
to shame. perl6 on the contrary knows about it.&lt;/p&gt;

&lt;h1 id=&#34;scalar&#34;&gt;scalar:&lt;/h1&gt;

&lt;p&gt;In a normal dynamic language a scalar consists of the three basic
types int, float and string, plus refs, and sometimes booleans and
null.  Those basic types are usually implemented either as fast
primitives, using only one or two stack slots, such as e.g. lisp
fixint, doubles with nan-tagging, null, booleans and the big scalars
on the heap.  refs can contain a class pointer to create
&amp;ldquo;objects&amp;rdquo;. Anything can be an object. In common lisp e.g. those
primitives contain two stack slots, the class and the tagged primitive
values.  A function is everywhere a big scalar.&lt;/p&gt;

&lt;p&gt;In perl5 there are no unboxed values on the stack, there is not even a stack.
Not for arguments and return values, not for lexicals and temporaries.
The normal design problem in a computer language how to find &amp;ldquo;upvalues&amp;rdquo;,
lexicals which are not temporaries on the stack, but rather are closed over
on stacks of upper functions. In perl5 this was simplified by using &amp;ldquo;pad&amp;rsquo;s&amp;rdquo;,
seperate flat arrays with indices or usable and reachable ranges. This is
quite ok, but accessing a stack entry is still 50x faster.
And mosty writing a temporary or lexical is very slow in perl5, as you
cannot overwite just the single or double stack values, you need to change
4-10 slots on the heap, esp. keep track of refcounting. Remember why php7
is 2x faster? Smaller data and they got rid of unneccessary refcounting.&lt;/p&gt;

&lt;p&gt;The cow hack for strings is not only totally unacceptable and slow. It
is also totally unmaintainable. I tried to fix and rewrite it two times
already.&lt;/p&gt;

&lt;h1 id=&#34;array&#34;&gt;array:&lt;/h1&gt;

&lt;p&gt;In normal languages you provide fast access to array elements, per default
or optionally. Even lisp can do that.
In perl5 this is not possible. (well, it is in cperl and perl6, but p5p has
no idea about that).&lt;/p&gt;

&lt;p&gt;First, every index can be negative to index it from the end.&lt;/p&gt;

&lt;p&gt;Second, every single object can be tied.&lt;/p&gt;

&lt;p&gt;Third, every single value in the array is a reference to somewhere
else on the heap. There are no natively typed arrays consisting only
of ints or doubles (primitives). Every access and update is not in
place, it involves the reference on the heap.&lt;/p&gt;

&lt;p&gt;Forth, there are no optimizations to eliminate run-time bounds checks.
cperl and perl6 have shaped arrays.
Every self-respecting language supports bounds checks elimination.&lt;/p&gt;

&lt;p&gt;Fifth: there are no overflow checks, indices silently overflow.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -e&#39;@a=(0,1);print $a[~1]&#39;
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;~1 is essentially (UV)-2 or 0xffff_fffe. It&amp;rsquo;s the highest unsigned
positive value - 1, but here in this case it wraps around to -2. Which
is arguably wrong.  But this is different to that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -Dt -e&#39;print $a[~1]&#39;
(-e:1)  const(IV(1))
(-e:1)  complement

EXECUTING...

(-e:0)  enter
(-e:0)  nextstate
(-e:1)  pushmark
(-e:1)  gv(main::a)
(-e:1)  rv2av
(-e:1)  const(IV(18446744073709551614))
(-e:1)  aelem
(-e:1)  print
(-e:1)  leave
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, you see that right. It is creating an array with
18446744073709551614 elements, accesses the last element and returns
that undef value.
And now the best trick:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl -e&#39;@a=(1);print $a[18446744073709551615]&#39;
=&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, you see that right. perl5 silently overflows the index to the
index 0 and returns its value. Same as above where ~1 silently
overflows to -2.  cperl fixed that btw. by throwing a compile-time
&amp;lsquo;Too many elements&amp;rsquo; error.  Silent wrapping on overflow is not a
language feature, it&amp;rsquo;s a bug. Only p5p keeps up with the narrative
that this a feature as designed.&lt;/p&gt;

&lt;h1 id=&#34;hash&#34;&gt;hash:&lt;/h1&gt;

&lt;p&gt;There is no knowledge of hash tables within p5p. The first re-implemention
after a DoS attack with 5.8.1 made a grave optimization mistake, which I
did not do when I fixed the old 5.6 hashes. Then a similar mistake was
detected with 5.18 when the used hash function was not zero-invariant.
You could produce collisions by adding \0 anywhere.&lt;/p&gt;

&lt;p&gt;There is no single hash table implementation out there in the open
public which is worse than perl5&amp;rsquo;, and I looked around a lot. But the
friends of p5p convinced wikipedia that the perl5 hash table is a
specially well-made and heavily optimized version, because everything
in perl5 is done via hashtables. symbol tables, objects, maps. This is
exactly how p5p sees itself.&lt;/p&gt;

&lt;p&gt;In reality not even the design is wrong, also the implementation.  The
simple slow linked list idea is horrible and is getting worse and
worse over the decades. The inner loop consists of 4 comparisons
instead of one. The pre- and post overhead is gigantic. They have no
idea about proper security and came up with hotch-potch ideas to slow
it down. Which is interesting because the guy who decided to break it
even more, works in the same company as a guy who knows about proper
hash table implementions a lot and does exactly this at this
company. Just in C++.&lt;/p&gt;

&lt;p&gt;The collision resolution strategy is caused by fear and security
theatre, not rational thinking. Everybody else uses move-to-front,
perl uses randomized iterators and random flipping.  perl5 uses a 100%
fill rate, while testing a proper fillrate lead to better rates with
80-90% as everyone else. There&amp;rsquo;s not even an option to try it,
and then using &lt;code&gt;_builtin_ctz&lt;/code&gt; (count trailing zeros) to use it efficiently.&lt;/p&gt;

&lt;p&gt;Rewriting the horrible hash tables to a proper open chained cache
friendly variant would be a very nice to have, but since the p5p
refactoring made it so bad, it&amp;rsquo;s a really hard job to do now.  There
four different hash searches around, three different hash table
element types. There&amp;rsquo;s no abstraction, so many external XS modules
have to access internals looping through the collisions.  It would
have been trivial with Larry&amp;rsquo;s old hash tables.
I needed essentially half a year just to abstract away all the
existing cruft, to be able to try out the usual hash table
variants. So better hash tables are not in v5.26c.&lt;/p&gt;

&lt;p&gt;Marc Jason Dominus gives a trivial explanation of perl chaining vs
python&amp;rsquo;s linear addressing 2015 at
&lt;a href=&#34;https://www.youtube.com/watch?v=u14GpzuTBjg&#34;&gt;https://www.youtube.com/watch?v=u14GpzuTBjg&lt;/a&gt;
but cannot explain performance benefits, how and why perl tombstones
are needed (he says only python needs it), nor explain any modern hash
table or security issues with the collision chaining. Nor does his
talk explain the various important historic errors porters did from
5.6 to 5.18, regarding ordering, random seeding vs uniform hashing,
wrong optimizations. Nor does he mention the recent python and ruby
2.4 hash table refactors, which do address all these issues.  Porters
themselves cannot even understand open addressing, let alone basic hash
table security and performance.&lt;/p&gt;

&lt;p&gt;Then hash keys: Hash keys are silently capped at I32_MAX, without any
warning or error. Longer keys are silently accepted and hashed, but
the hash is wrong because the length silently overflows and the key is
wrong because it is too short. Technically you could accept longer
keys and turn them into SV&amp;rsquo;s, but even this is not done.
This is not a policy, this is pure incompetence.
cperl errors with overlong names/hash keys.&lt;/p&gt;

&lt;h1 id=&#34;regex&#34;&gt;regex:&lt;/h1&gt;

&lt;p&gt;The regex compiler is a hack and is unmaintainable. It is the old
Henry Spencer compiler code from 1988, where logic branches are done with
&lt;code&gt;setjmp&lt;/code&gt;/&lt;code&gt;longjmp&lt;/code&gt;, where the regex is parsed twice, but the result of the
first parse is not used to switch to a better compilation and
run-time, as critized by Russ Cox decades ago, leading to &lt;strong&gt;re2&lt;/strong&gt;,
with a linear run-time without backtracking.&lt;/p&gt;

&lt;p&gt;The problem of backtracking stack exhaustion was not fixed by
switching the compiler, and using the 2 pass information. Rather the
simple and maintainable recursion code was rewritten into iteration,
leading to even worse and slower code. There&amp;rsquo;s still no stack limit.
So the small stack limit is now replaced by the larger heap limit,
leading to even nicer and more effective DOS attacks. davem&amp;rsquo;s rewrite
didn&amp;rsquo;t make it safer, but worse and 10% slower. He&amp;rsquo;s still proud of
it though.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no sign of taking over libpcre, which has a jit in the
mean time, and add the missing unicode name support there. The libpcre
maintainers are clearly more competent than p5p and this might have
led to undesirable discussions.
Note that the p5p regex maintainers have no idea what I&amp;rsquo;m talking
about here. They also ridiculed Russ Cox when he complained and
offered improvements. What they did then was the policital correct
idea, to offer an API for alternative implementations because they
were not able to fix their own. This did not help at all.&lt;/p&gt;

&lt;h1 id=&#34;functions&#34;&gt;functions:&lt;/h1&gt;

&lt;p&gt;How perl5 calls a function is horrible, first because of the primitive initial
design with custom stacks and pads. The ability to localize and throw from
everywhere (there&amp;rsquo;s no compile time detection and optimization). The lack of
typed signatures, all the args and return values are copied to @_, and not
kept on the stack as with better XS interface.&lt;/p&gt;

&lt;h1 id=&#34;methods&#34;&gt;methods:&lt;/h1&gt;

&lt;p&gt;perl5 supports only single dispatch on the first argument. Improving
the other builtin ops, esp. binops but also generic ops works via
overloading them, i.e. runtime lookup if this method is overloaded.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no multiple dispatch as in perl6, and the usual strategy to
speed up such method calls is &amp;ldquo;PIC&amp;rdquo;, polymorphic inline caching, which
might store a hash of all used classed per method to avoid costly
run-time lookups.  There came a patch from russia, which implemented
that quite efficiently, but p5p managed to simplify that down to a
naive monomorphic inline caching (only cache the latest), which is
what we have since with 5.22.  That&amp;rsquo;s why it&amp;rsquo;s suddenly 20% faster but
could have been 30%.&lt;/p&gt;

&lt;p&gt;They never heard of that term, and it is better to avoid any technical
terms with them, as they they have no idea what you are talking about.
Their are mostly sysadmins with no CS background.  But they are very
happy to invent new terms for existing technologies under a different
name to avoid scrunity.  e.g. they call mixins &amp;ldquo;roles&amp;rdquo; and attributes &amp;ldquo;traits&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no method keyword, and the existing &lt;code&gt;:method&lt;/code&gt; attribute bitrotted
because it is of no use. As signatures and an object system didn&amp;rsquo;t make it
into perl5.&lt;/p&gt;

&lt;p&gt;There is a lot of talking about a &amp;ldquo;Modern Perl&amp;rdquo; movement, using Moose and
signatures, but they have no idea what they are talking about.  Moose is a
post-modern naive and inefficient implementation of the perl6 object system
with a bit of CLOS, but without the cleaner perl6 syntax.  A &amp;ldquo;modern&amp;rdquo; system
would follow the &amp;ldquo;form follows function principle&amp;rdquo;, it would be lean and
efficient.  But Moose is an enormous and naive hack without any proper core
support from within, and entire hodge podge of workarounds around the
impossibility within perl5 to store compile-time generated classes per
pointer. every class and method is being looked by name, and name lookup
is not efficient due to the inefficient hashes, it is also inefficient due
to the inefficient and naive design of the perl5 symbol tables. nested
hashes of hashes and not one flat hash table as symtab.
efficient lexical lookup is unheard of, p5p did never come to help.
Lookup by pointer is impossible.&lt;/p&gt;

&lt;p&gt;Mouse would be the &amp;ldquo;modern&amp;rdquo; and efficient variant of Moose and is
about 10x faster, but it still has to follow the awkward and unnatural
Moose syntax and not the tighter and more natural perl6 syntax.&lt;/p&gt;

&lt;h1 id=&#34;symbols&#34;&gt;symbols:&lt;/h1&gt;

&lt;p&gt;I already mentioned the initial naive and slow implemenation as hash
of stashes (stash = symbol table hash). This also leads to surprising
language inconsistencies which initially was considered a language
quirks, which would be eventually fixed (and it would be quite trivial
to fix), but just this year p5p announced suddenly that it will never
be fixed. it&amp;rsquo;s now part of the language.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m speaking of autovivification, the fact that when you ask if a symbol or
stash exists, it does not exist, but all intermediate stashes in the
namespace get magically polluted by that query, and a query to a previously
not existing stash will now return yes. It&amp;rsquo;s a parser bug with the namespace
lookup, which will be fixed with cperl and is fixed in perl6. But p5p
decided that such a bug is now a feature. Action at a distance is a language
feature, because perl is magic and dynamic.
In my opinion it&amp;rsquo;s only caused by gross p5p incompetence, not even knowing
the history of perl5 anymore. This bug was always considered a bug.&lt;/p&gt;

&lt;p&gt;See also unicode security below.&lt;/p&gt;

&lt;h1 id=&#34;binary-symbols-and-names&#34;&gt;binary symbols and names:&lt;/h1&gt;

&lt;p&gt;For 5.16 a google summer of code student wanted to improve the support
for unicode names, symbols and packages. UTF8 was already supported
since 5.8.4 with a negative length in a HEK (hash key), where names
are stored. But the external API was lacking a bit.&lt;/p&gt;

&lt;p&gt;But what eventually went into 5.16 without any public notice was
support for binary names, names which include \0. This is not a valid
unicode character and this broke many previous sound
assumptions. First, we had a way to hide some symbols behind a \0, and
there was one which was used that way. This was now broken.  Second
and more important are the security aspects. The external API via
syscalls using names and files does not accept those names. You can
declare different packages mapping to the same file being loaded from
disc. Over and over.  You can hide anything behind symbol and packages
names, and nobody will find out, because everything behind the \0 is
ignored, when using external API calls. This was quite a problematic
change, which nobody knows about because it was never announced, and
even the current maintainer does not know about it. He gave a XS
primer talk at a YAPC explaining how easy it is to work with XS, but
he still used the old wrong API without support for binary names.
Until this day, 10 years after, there are no PPPort macros to support
binary names with old XS code.  The p5p argument for this was: &amp;ldquo;we
sanified the API, it is now consistent&amp;rdquo;.  Which means that all &lt;code&gt;gv_*&lt;/code&gt;
calls broke and needed a new version with an extra len argument just
to support binary names.&lt;/p&gt;

&lt;p&gt;Technically binary names to support any junk for readable names is
very problematic regarding
&lt;a href=&#34;http://websec.github.io/unicode-security-guide/&#34;&gt;TR39&lt;/a&gt;, the handling
of confusables, mixed scripts and syntax spoofs. In perl5 it is easy
to hide malicious unicode code in source code, i.e. hiding in hidden
right-to-left sequences or hiding different names with similar looking
characters, and there&amp;rsquo;s no confusables check in the parser, something
like &lt;code&gt;use strict &#39;names&#39;&lt;/code&gt; to accept only parsable names without
accepting confusables. cperl fixed a couple of major unicode security
issues since and follows the unicode security profiles for identifiers.
Apparently it is the first and only language implementation which does so.&lt;/p&gt;

&lt;p&gt;And the second problem is the unfortunate layout of the
global symbol table as nested hash of hashes (&amp;ldquo;stashes&amp;rdquo; - symbol table
hash). Every lookup in a longer package name, not using a lexical
variable or function or method call needs to look the name in a series
of nested hashes, and not just in one global symbol tables, as in all
other dynamic languages. Now with full support for binary names
(i.e. any junk) the flood gates are open, and optimized variants for
symtabs are not usable anymore.&lt;/p&gt;

&lt;p&gt;perlcperl.pod has this section:
&amp;ldquo;Check converting the GV stash tree of hashes into a single global data
structure, not a nested hash of hashes: Hash, AVL tree, Trie (TST or
RÂ² TST), Patricia trie or DAFSA (Deterministic acyclic finite state
automaton) for faster dynamic variable and function name lookup. No
binary names, all as UTF8. Maybe restrict to ASCII or valid
identifiers to limit the trie memory (array of 26 vs 256).  Stashes
point then to trie nodes and need a HV check.  Optionally provide
partial read-only support for the compiler, as for &lt;code&gt;PL_strtab&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course p5p is not aware of any unicode or binary name problems,
optimization possibilities or alternative implementations. The only
other one who complained was Tom Christianson; about right-lo-left
problems (bidi spoofs).&lt;/p&gt;

&lt;h1 id=&#34;lack-of-understanding-of-basic-vm-techniques&#34;&gt;lack of understanding of basic vm techniques&lt;/h1&gt;

&lt;p&gt;The VM, the runtime part of the interpreter, is still a nightmare.  It
would be easy if anybody would actually listen to someone who has an
idea, like e.g. Larry himself.&lt;/p&gt;

&lt;p&gt;We carry around way too much bloat in the ops and the data, which is
not needed at run-time. e.g. the compiler throws away the nested
symbol table stashes if not needed, which frees 20% memory.
But think of a lua/p2-like redesign of tagged values and slimmer ops,
and eventually put the stack onto the CPU stack.&lt;/p&gt;

&lt;p&gt;Note that p5p argues the opposite way. They want to add even more
run-time branches to the ops, without any justification.&lt;/p&gt;

&lt;p&gt;perl5 has no proper stack. Their stack is on the heap. which is 50x
slower to access and needs manual destruction. Destruction on the
stack is free. The stack is also not refcounted. &lt;em&gt;(Thanksfully, but
they want to dstroy even that nowadays.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Perl needs to optimize special arithmetic op sequences to use unboxed
integers and strings on the stack. There&amp;rsquo;s a reason why in normal
languages short lived variables are kept on the stack and not on the
heap. Why values can easily be updated.  cperl does experiment in
allowing unboxed values on the stack, because the stack is not garbage
collected and not refcounted.  Same as in perl6. We just need to be
sure to box them before entering a non-collaborating sub, leaving a
block with possible exceptions and stack cleanup. Those unboxed values
are internally typed as &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.  Note that the coretypes
&lt;code&gt;int&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; are not guaranteed to be unboxed, only if the compiler
sees fit, same as in perl6. In most cases those values are boxed but
without a class pointer and magic attached.&lt;/p&gt;

&lt;p&gt;Maybe rewrite to a better register-based compiler with fixed-length 2
operands as in p2, but this might be too tricky for XS, mapping the
global stack to the local stack.  Probably no SSA (three arguments),
just a cpu friendly two argument form as in p2/lua 5.1.&lt;/p&gt;

&lt;p&gt;Allow faster XS calls, user-provided function calls and method calls.
Provide support for named arguments in the vm, fast not via hashes.
Many of the current io+sys ops are better implemented as library
methods.  With ~50ops instead of &amp;gt;300 the runloop might fit into the
L1 cache again.  Seperate calling of fixed arity methods from varargs.
detect and use tailcalls automatically.  Do not step into a seperate
runloop for every single function call, only for coros, which do need
to record the the stack information.&lt;/p&gt;

&lt;p&gt;Run-time optimize the data, no 2x indirection to access hash and array
structs. Provide forwarding pointers to single tuples to hold all.
This could provide also the possibility for a GC if a second sweep
for timely destruction is doable.&lt;/p&gt;

&lt;h1 id=&#34;no-plan&#34;&gt;no plan&lt;/h1&gt;

&lt;p&gt;p5p lacks a proper todo list, just a small pathetic collection of
useless and tiny ideas in &lt;code&gt;Porting/todo.pod&lt;/code&gt;. Nothing came ever out of
it. Larry had a proper todo long time ago, but p5p deleted it since,
to avoid looking too bad.
They have no idea what to do, what to improve and how to go
forward. For example some years ago I mentioned the simple idea to
seperate XS and PP function call ops.  I implemented it easily in a
few days with a 10% gain, but they deleted it from their todo list as
not worthwhile (&amp;ldquo;entersub XS vs Perl&amp;rdquo; db1070bec96) and they removed
the official man page of perltodo.pod.&lt;/p&gt;

&lt;p&gt;Their feature discussions and design is not working.  Larry had a
proper todo list in the very old days, including sound and worthwhile
goals, like a ffi, types, signatures, an object system. But this was
deleted by p5p in the early years.&lt;/p&gt;

&lt;p&gt;Their big ideas consists of: &amp;ldquo;make ithreads more robust&amp;rdquo;. Yes, that is
all.&lt;/p&gt;

&lt;h1 id=&#34;signatures&#34;&gt;signatures&lt;/h1&gt;

&lt;p&gt;signatures should have been added to core for 15 years. proper
external implementations do exist. they are properly designed in
perl6, there are no design problems, just lack of knowledge how to do
it.&lt;/p&gt;

&lt;p&gt;The first attempt was adhoc, simply splicing the optree into the
function.  At least this version had proper callbacks for
introspection. But the discussion about this attempt was pure
bikeshedding, nothing came out of it, and in the end it was not
done. Explicit attempts to help and improve it were ignored. The
second attempt (&lt;em&gt;purple&lt;/em&gt;) was by a core committer, and was technically even
worse. For example the arity check was twice as slow as necessary, the
implementation two times slower than not using signatures at all, most
of the signatures features were missing. These purple signatures went in
because it was by a committer, even when the design had grave mistakes.
The next attempt also by a core committer was a bit faster and used
the same trick as with the multideref optimization. but internally it
was still lacking proper design, it still copied all values to the
magic &lt;code&gt;@_&lt;/code&gt; array and was thereby still slower than not using
signatures. And no features being used in perl6 and all other external
CPAN implementations were added.  no types, no self invocant keyword,
named args, &amp;hellip;
Esp. types are crucial for a modern perl, but switching to the XS api
with the arguments on the stack would have also been crucial. Which is
esp. interesting since cperl already had a proper signature
implementation which was 40% faster than not using signatures, and
many compile-time checks improve code quality and readability.&lt;/p&gt;

&lt;h1 id=&#34;modules&#34;&gt;modules&lt;/h1&gt;

&lt;p&gt;My &lt;a href=&#34;http://blogs.perl.org/users/rurban/2016/04/overview-of-current-maintainer-fails.html&#34;&gt;blog.perl.org&lt;/a&gt;
post lists all of the important modules maintenance failures as of
5.24.0, and p5p was the biggest part in it. There are no inaccuracies
in this post, since I personally fixed all of these problems by
myself, but I was blocked by the maintainers to respond to the
criticism there.&lt;/p&gt;

&lt;p&gt;But there&amp;rsquo;s much more. Rarely passes a p5p maintained module the basic
bullshit test.  Storable cannot deal with overlarge data and writes on
its stack. Unicode::UCD is as horrible as the internal unicode invlist
layout, using plain huge strings in files, which are split at runtime
to invlists, stored in SV&amp;rsquo;s, and then binary searched. Which is 800%
slower and much larger than a normal pre-compiled data structure, as
it would have been done when a cpan author would have maintained
it. Such as e.g. Encode or Unicode::Normalize.  And this static
read-only and uniform data should be compiled to a shared library as
Encode does it.  strict, vars, warnings, Config, Exporter, DynaLoader,
XSLoader, B, re, Filter and many more are either in a horrible and
unacceptable state, or I stepped up and took it over. Basically the
only acceptable internal module is Win32CORE and CharClass::Matcher to
compile character class search to almost efficient .h code.&lt;/p&gt;

&lt;h1 id=&#34;security&#34;&gt;Security&lt;/h1&gt;

&lt;p&gt;Not talking about that, since the security discussions were secret,
while certain members of that list brought my description how to hack
something, e.g. DBI to the public without fixing it. He fixed it
(applied y patch sitting in his queue) one year later eventually.  The
overall impression is that they are totally incompetent, and they
continue to be incompetent. With cperl alone Iâm fixing 4 new security
problems per release, and only one of them ever made it into perl5
since.  When they announced 5.24.1 I had publicly listed 24 known
problems with 5.24.0, and they indented to fix none of them. After a
few months of waiting for that bugfix release they at least agreed to
fix a few of them, but make every effort not to cherry pick my
fixes. Active hostility and refusal to cooperate.&lt;/p&gt;

&lt;p&gt;Just look at the many many security problems cperl has fixed
since. p5p only picked up one of it: &lt;code&gt;-Dfortify_inc&lt;/code&gt; but even managed to
change it&amp;rsquo;s API since then.&lt;/p&gt;

&lt;p&gt;I warned against binary and unicode symbols since its invention with
5.16.  Nothing has happened since, only cperl made progress in
disallowing mixed scripts and normalizing identifiers.&lt;/p&gt;

&lt;h1 id=&#34;death-by-code-of-conduct&#34;&gt;Death by code of conduct&lt;/h1&gt;

&lt;p&gt;The last maintainer had the idea to improve the discussion problems,
the constant angry and fruitless discussions, name calling and racist
remarks by a new code of conduct. It didn&amp;rsquo;t help, instead it
backfired. Certain p5p members who still happily enjoy to break the
new code of conduct are not even warned about breaking any rule, they
still serve as public figure heads, give the main YAPC conference
talks and are allowed to call certain users assholes every year in the
conference keynote. For years. But the ones who technically critise p5p and try
to improve the lock-in were not only being called assholes and trolls,
they were even removed for breaking the unwritten but publicly emailed
rule of this COC, &amp;ldquo;that you should have faith in p5p&amp;rdquo;. Which is
ridiculous given their track record.  By not having faith into these
maintainers you are not allowed to be member in this community, are
being blocked from posting to their blog, mailing list and access the
bugtracker. an outragiously broken community. After the fork they
became actively hostile and broke all communication.  But the code of
conduct served its goal, the community is now officially broken and
dead. And perl5 officially became a &lt;a href=&#34;cperl-is-not-a-religion.html&#34;&gt;religion&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;closing&#34;&gt;Closing&lt;/h1&gt;

&lt;p&gt;The signatures desaster is one of the most apparent signs of the
collective and individual p5p incompetence. I would argue the
complete lack of any success in their whole 15 years of maintainance
is a bigger tellsign.&lt;/p&gt;

&lt;p&gt;But we all can live with incompetence. We all know managers and do
work in companies, and we all know the peter principle. A bigger
problem than incompetence is being actually &lt;strong&gt;destructive&lt;/strong&gt;. Within
p5p the key figures turned out to be not only incompetent and some of
them arrogant and unpleasant human beings, but actually destructive in
removing features when they are not able to maintain it anymore,
destroying performance, destroying the code base maintainability,
causing pain to cpan maintainers and generally doing and talking
nonsense. This is the main reason why I became active in protesting
these tendencies.&lt;/p&gt;

&lt;p&gt;Most more competent people left the perl community silently years ago,
there&amp;rsquo;s no talent anymore, that&amp;rsquo;s why it&amp;rsquo;s easy to come up with such
an incompetent group and maintain this status for 15 years.  And
sometimes, when there&amp;rsquo;s fresh talent, and actually turned out to come
with better ideas and implementatioms those ideas don&amp;rsquo;t make it into
the codebase. The dead wood is protecting its turf.&lt;/p&gt;

&lt;p&gt;I offered solutions to fix those problems multiple times, and was
being shouted at.  The only thing helping now is to dissolve the perl5
porters from being the language maintainers committee, and just be the
porters. that&amp;rsquo;s what they can do. Nothing else.  Immediately remove
commit access to the ones who are doing the ongoing damage.  There is
no need for them acting like a language committee since Larry and then
perl6 already did that, just ensure to keep backwards compatibility.&lt;/p&gt;

&lt;p&gt;Ensure a working management. This is not solvable. Electing community
and people managers who should manage opposing opinions makes no
sense, since there will be no agreement, the manager has no idea what
they are talking about because he is the technically most incompetent
of all, and the existing devs showed no sign of competence and
managebility. Most features were brought in by bypassing processes
and management.&lt;/p&gt;

&lt;p&gt;In cperl and perl6 we use public trackers and irc, no mailing-list.
Features and bugfixes are developed by proper process.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-5xof5n-p5p-incompetence&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/5xof5n/p5p_incompetence/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&amp;ndash;
Reini Urban&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The dangerous SipHash myth</title>
      <link>http://perl11.org/blog/seed.html</link>
      <pubDate>Sat, 26 Nov 2016 12:35:00 +0200</pubDate>
      
      <guid>http://perl11.org/blog/seed.html</guid>
      <description>&lt;p&gt;SipHash claims that its &amp;ldquo;cryptographically strong pseudo random
function&amp;rdquo; properties protects against hash table DoS flood attacks.
This is wrong, because for a successful attack against a SipHash hash
table with chained linked lists or linear probing it is enough to get
the secret random seed, and then brute force create collisions, which
is doable in &amp;lt;1s for 16k keys, 2m for 16k keys, and from 32k to 268M
keys in 4 minutes. For any hash function, SipHash, AES or even SHA256.
Which is far from being secure. Declaring a hash function for a hash
table secure is wrong and pure security theatre, which unfortunately
a lot of people started to believe in.&lt;/p&gt;

&lt;p&gt;Normally you can prepare collisions offline, but as you see you can
even create them online as soon as you know the seed.  Inserting 64k
keys needs 32 seconds vs 0.01 seconds on e.g. PHP, from constant to
quadratic, with an amplification factor of 200.
&lt;a href=&#34;https://events.ccc.de/congress/2011/Fahrplan/events/4680.en.html&#34;&gt;https://events.ccc.de/congress/2011/Fahrplan/events/4680.en.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So the only protection is the secrecy of the random seed, which has
nothing to do with any properties of SipHash per se. A hash
function can never protect a hash table from hash flood attacks on
hash tables with simple lists on collisions. SipHash properties are
that is not reversible, the seed is mixed in the box and not only
at the beginning, so it&amp;rsquo;s is hard to get the seed from the hash
function itself. But there&amp;rsquo;s no need for it, as it is trivial to
get the seed via other means. The collisions are prone to timing
attacks independent on the hash function, usually the hash
iterator exposes the inner ordering and in most cases the random
seed is exposable via traditional memory exposure. If the seed is
hash table specific or global, i.e. process or thread specific.&lt;/p&gt;

&lt;p&gt;E.g. in debian perl you get the seed at process startup via&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ PERL_HASH_SEED_DEBUG=1 /usr/bin/perl -e0
=&amp;gt; HASH_FUNCTION = ONE_AT_A_TIME_HARD HASH_SEED = 0xd12d459fc36db4cf PERTURB_KEYS = 1 (RANDOM)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to stderr.&lt;/p&gt;

&lt;p&gt;On centos7:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ PERL_HASH_SEED_DEBUG=1 /usr/bin/perl -e0
=&amp;gt; HASH_SEED = 10452142639498245987
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Older centos 5 and 6 has an unpatched perl hash table function which
is vulnerable to much simplier DoS attacks, which is e.g. used on the
redhat openshift public cloud.&lt;/p&gt;

&lt;p&gt;For a running perl process the seed is at a known fixed offset.  Which
is easily readable via some kind of poke function via the unpack &amp;ldquo;P&amp;rdquo;
builtin op. See Devel::PeekPoke.  Similar for all other dynamic
languages exposing the value of any pointer. Which is esp. problematic
for languages who trusted the false claims of the SipHash authors,
that using this secure hash function it makes it safe against such DoS
attacks. Which are most prominently ruby, python, rust, haskell and
others.  Perl5 at least changed the order of the iterator, cperl
counts the collisions and adds a sleep on attacks, PHP limits the size
of external keys to be passed to the hash table so only JSON or other
formats are easily DoS-able. But more serious applications such as the
linux kernel, glibc, cache or DNS servers use better hash table
collisions schemes than unsafe chaining or linear probing.&lt;/p&gt;

&lt;p&gt;Vulnerable are all implementors of hash tables who believed the false
claims of the SipHash authors: ruby, python, rust, haskell, OpenBSD
and some more.  But also others who don&amp;rsquo;t use a proper hash table
collision resolution scheme or don&amp;rsquo;t protect their seed or easily
expose the seed, such as perl5 and many more.  rust currently
e.g. believes that SipHash makes it secure even if a trivial attack
was just found against it, and changing the seed at table resize will
help. It only helps a bit.  The seed is still exposable.  With an
amplification factor of 200 with a table size large enough there&amp;rsquo;s
enough attack surface to render a service useless.
Reseeding on resize will lead to an amplification factor of 6.&lt;/p&gt;

&lt;p&gt;Links:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/highwayhash/issues/28&#34;&gt;google/highwayshash False security claims&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rurban/smhasher/#security&#34;&gt;SMHasher on Security&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rurban/perl-hash-stats&#34;&gt;perl hash stats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>cperl is not a religion</title>
      <link>http://perl11.org/blog/cperl-is-not-a-religion.html</link>
      <pubDate>Tue, 05 Jul 2016 12:35:00 +0200</pubDate>
      
      <guid>http://perl11.org/blog/cperl-is-not-a-religion.html</guid>
      <description>

&lt;h1 id=&#34;the-recent-perl5-management-problems-are-disturbing&#34;&gt;The recent perl5 management problems are disturbing&lt;/h1&gt;

&lt;p&gt;Criticizing the broken perl5 development process, the managers and esp. various technical problems is suddenly explicitly disallowed in the various perl5 forums by citing a new &amp;ldquo;bad faith&amp;rdquo; code of conduct rule. Mentioning incompetence of submitters is considered uncivil, and mentioning the marketing lies of the previous &amp;ldquo;pumpkin&amp;rdquo; (admin) is also considered uncivil. But lying, abusing the powers, and constant usage and even encouragement of foul language is interestingly not considered uncivil.&lt;/p&gt;

&lt;p&gt;cperl was initially created to overcome technical debt created by the current maintainership, who refuse to use a proper development process, refuse to take back wrong technical decisions which are blocking critical progress, and even discussing it. And mostly the complete lack of progress since 2001, but rather a disturbing series of grave technical mistakes and detoriation of the code base.&lt;/p&gt;

&lt;p&gt;We favor community-friendly democratic development policies as e.g. in perl6 over the usual old-style dictatorial model. That means the powerful (those with management and commit roles) are not allowed to abuse their powers, while the powerless users are allowed and need to have the abilities to criticise them and their code.&lt;/p&gt;

&lt;p&gt;In the old trust-based dictatorial model as e.g. in linux or perl5 the powerful call the not powerful abusive names (&amp;ldquo;asshole&amp;rdquo; or &amp;ldquo;jerk&amp;rdquo; is very common, or &amp;ldquo;trolls&amp;rdquo;), and are allowed to avoid discussions of features or problems by directly committing to master, rejecting tickets or selectively abuse their powers. This is forbidden in cperl.&lt;/p&gt;

&lt;p&gt;What want to give a forum to discuss future directions of the perl5 language, merging most of the perl6 features without breaking existing code.&lt;/p&gt;

&lt;p&gt;Such a discussion is historically not possible in the perl5 porters list, and now even not in the /r/perl subreddit anymore. Thanksfully cperl managed to overcome most of the stagnation of the last 10 years, within only one year of development. But most of the new features are only 90% finished.&lt;/p&gt;

&lt;p&gt;Interesting discussions would be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;how to fix p5p&lt;/li&gt;
&lt;li&gt;how to create a proper development process (hint: see what the others did)&lt;/li&gt;
&lt;li&gt;details of the new cperl features in development:
signatures, type system, inlining, symbol table, hashes, jit (tracing or method),
ops, class+method keywords, multi dispatch, native types, builtin ffi, native compiler
(unexec), &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://www.reddit.com/r/cperl/comments/4folk1/cperl_is_not_a_religion/&#34;&gt;Comments on /r/cperl/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>