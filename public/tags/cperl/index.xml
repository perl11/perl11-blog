<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cperl on perl11 blog</title>
    <link>http://perl11.org/blog/tags/cperl.xml</link>
    <description>Recent content in Cperl on perl11 blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© 2016 Copyright Reini Urban</copyright>
    <atom:link href="http://perl11.org/blog/tags/cperl.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Attributes arguments</title>
      <link>http://perl11.org/blog/attributes-args.html</link>
      <pubDate>Sat, 27 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/attributes-args.html</guid>
      <description>

&lt;h1 id=&#34;perl5-had-broken-attribute-handling-forever&#34;&gt;perl5 had broken attribute handling forever&lt;/h1&gt;

&lt;p&gt;perl5 attributes were invented to provide extendable hooks to attach
data or run code at any data, and made for nice syntax, almost
resembling other languages.&lt;/p&gt;

&lt;p&gt;E.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $i :Int = 1;
sub calc :prototype($$) { shift + shift }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There were a few number of builtin attributes, like &lt;code&gt;:lvalue&lt;/code&gt;,
&lt;code&gt;:shared&lt;/code&gt;, &lt;code&gt;:const&lt;/code&gt;, adding a flag to a function or data, and you could
add package-specific for compile-time or run-time hooks to process arbitrary custom
attributes.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;&amp;amp;MyClass::FETCH_SCALAR_ATTRIBUTES&lt;/code&gt; hook would be called on every
not-builtin &lt;code&gt;MyClass::&lt;/code&gt; scalar attribute at run-time, and
&lt;code&gt;&amp;amp;MyClass::MODIFY_SCALAR_ATTRIBUTES&lt;/code&gt; at compile-time.&lt;/p&gt;

&lt;p&gt;If you would want to process attributes in all classes you&amp;rsquo;d need to add &lt;code&gt;UNIVERSAL&lt;/code&gt; hooks
or use handlers like &lt;code&gt;Attribute::Handlers&lt;/code&gt;.
This would simplify declaring code for attributes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub Good : ATTR(SCALAR) {
    my ($package, $symbol, $referent, $attr, $data) = @_;

    # Invoked for any scalar variable with a :Good attribute,
    # provided the variable was declared in MyClass (or
    # a derived class) or typed to MyClass.

    # Do whatever to $referent here (executed in CHECK phase).
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the last &lt;code&gt;$data&lt;/code&gt; argument above. This is the optional argument
for an &lt;code&gt;:Good&lt;/code&gt; attribute, such as in
&lt;code&gt;my MyClass $obj :Good(print a number);&lt;/code&gt;. Do you see the problem?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$data&lt;/code&gt; will be the result of the evaluation of &lt;code&gt;print a number&lt;/code&gt;.
Which will create this error: &lt;code&gt;Can&#39;t locate object method &amp;quot;a&amp;quot; via package &amp;quot;number&amp;quot;&lt;/code&gt;.
This would be the correct declaration: &lt;code&gt;my MyClass $obj :Good(&amp;quot;print a number&amp;quot;);&lt;/code&gt;.
So &lt;code&gt;Attribute::Handlers&lt;/code&gt; is entirely unsafe by evaluating all attribute arguments.&lt;/p&gt;

&lt;p&gt;But Damian was right thinking of the use-cases. Attribute arguments
are needed to attach certain data to a variable of function. He just
didn&amp;rsquo;t implement it properly, as with all of his modules.&lt;/p&gt;

&lt;p&gt;E.g. in cperl we added type support via attributes:
&lt;code&gt;sub calc ($a:int) :int { $a + 10 }&lt;/code&gt; declares calc as returning an &lt;code&gt;int&lt;/code&gt; type, and the
&lt;code&gt;$a&lt;/code&gt; argument to accept &lt;code&gt;int&lt;/code&gt; types.&lt;/p&gt;

&lt;p&gt;For the upcoming cperl ffi (Foreign FunctionCall Interface) we need
attribute arguments more urgently.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sub random () :native :long;&lt;/code&gt; declares random as native function,
searched in all loaded shared libraries. I.e. &lt;code&gt;libc&lt;/code&gt; must already be
loaded. It is by default, so this works. But for non-default shared
libraries we need to specify the name of the library.&lt;/p&gt;

&lt;p&gt;Look e.g. at this perl6 NativeCall declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use NativeCall;
sub mysql_init( OpaquePointer $mysql_client )
    returns OpaquePointer
    is native(&#39;libmysqlclient&#39;)
    { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course this syntax is not ideal.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;returns OpaquePointer&lt;/code&gt; is abbrevated in cperl to &lt;code&gt;:OpaquePointer&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is native(&#39;libmysqlclient&#39;)&lt;/code&gt; has the syntax &lt;code&gt;:native(&#39;mysqlclient&#39;)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The empty &lt;code&gt;{ ... }&lt;/code&gt; block is of course left out. Ditto for &lt;code&gt;{ * }&lt;/code&gt;. This is superfluous syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A ffi declaration is just a declaration without a body. The body is looked up by the native
attribute, in the declared library, and optionally under the &lt;code&gt;:symbol(&#39;mysql_init&#39;)&lt;/code&gt; name.
See the &lt;a href=&#34;https://docs.perl6.org/language/nativecall#Changing_names&#34;&gt;p6 nativecall docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;cperl syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use NativeCall;
extern sub mysql_init( OpaquePointer $mysql_client ) :OpaquePointer :native(&#39;mysqlclient&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;extern sub&lt;/code&gt; declaration is syntax sugar, &lt;code&gt;extern&lt;/code&gt; means the same
as &lt;code&gt;:native&lt;/code&gt;, it just looks better, as in better languages.&lt;/p&gt;

&lt;h1 id=&#34;attribute-arguments&#34;&gt;Attribute arguments&lt;/h1&gt;

&lt;p&gt;Now to the &lt;code&gt;:native&lt;/code&gt; argument, the name of library. You saw in the
first zavolaj example the &lt;code&gt;lib&lt;/code&gt; prefix stated explictly. &lt;code&gt;is native(&#39;libmysqlclient&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will not work on windows and cygwin.  cygwin needs a &lt;code&gt;cyg&lt;/code&gt; prefix
and a version suffix, the dll is called &lt;code&gt;cygmysqlclient-18.dll&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On windows the library would be called &lt;code&gt;libmysql.dll&lt;/code&gt;, but this varies
wildly, as there&amp;rsquo;s no naming convention for shared libs, only for
import libs.&lt;/p&gt;

&lt;p&gt;The world is not made for FFI&amp;rsquo;s, just for linking libraries at
compile-time. There a &lt;code&gt;-lmysqlclient&lt;/code&gt; is enough, on windows this would
find &lt;code&gt;libmysqlclient.dll.a&lt;/code&gt; or &lt;code&gt;libmysqlclient.lib&lt;/code&gt;, which is an
import library which refers to the proper versioned name of the
current shared library. Remember that windows does not solve the
versionining problem of shared libraries via symlinks. One does not
load shared libraries directly on Windows.&lt;/p&gt;

&lt;p&gt;So your FFI mysql connector would do some little application logic, like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $libname = &amp;quot;mysqlclient&amp;quot;;
    $libname = &amp;quot;cygmysqlclient-18.dll&amp;quot; if $^O eq &#39;cygwin`;
    
    sub mysql_init( OpaquePointer $mysql_client ) :OpaquePointer :native($libname);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It cannot be solved in the native attribute handler unless you add the
version, like &lt;code&gt;:native(&#39;mysqlclient&#39;, 18)&lt;/code&gt;. Then the library searcher
can add some magic to find the proper shared library.  But it is
usually done application specific.&lt;/p&gt;

&lt;p&gt;But all this will not work in perl5, as perl5 has no proper way to resolve the
attribute argument &lt;code&gt;$libname&lt;/code&gt; at run-time. What perl5 does is parsing
&lt;code&gt;:native($libname)&lt;/code&gt; to the string &lt;code&gt;&#39;native($libname)&#39;&lt;/code&gt; and passes it
to &lt;code&gt;BEGIN { use attributes ... &#39;:native($libname)&#39;; }&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note &lt;code&gt;&#39;:native($libname)&#39;&lt;/code&gt; and not &lt;code&gt;&amp;quot;:native($libname)&amp;quot;&lt;/code&gt;,
i.e. &lt;code&gt;$libname&lt;/code&gt; is not expanded to it&amp;rsquo;s value, and it would not help much
as the call happens at compile-time, so &lt;code&gt;$libname&lt;/code&gt; would have been empty still.&lt;/p&gt;

&lt;p&gt;What it should have done instead is to inject the code
&lt;code&gt;use attributes ... &amp;quot;native($libname)&amp;quot;;&lt;/code&gt;, which is the equivalent of&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEGIN { require attributes; }
attributes-&amp;gt;import(__PACKAGE__, \&amp;amp;msql_init, &amp;quot;native&amp;quot;, $libname);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which means the import call needs to be deferred to run-time. perl5
does this only for &lt;strong&gt;my&lt;/strong&gt; variable attribute parsing, but not for functions.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;my $var :native($libname)&lt;/code&gt; would correctly call the importer at
run-time, but &lt;code&gt;sub random() :native($libname);&lt;/code&gt; would falsely call the
importer at compile-time, and the argument would not be parsed at
all. Everything is passed as string to the importer, and the hook
needs to parse the argument. Hence the Attribute:Handler security
nightmare, simply calling eval on all args. Which is a lot of fun
e.g. with a documentation attribute with &lt;code&gt;App::Rad&lt;/code&gt;, when your
docstring is eval&amp;rsquo;ed.&lt;/p&gt;

&lt;p&gt;Now with cperl there are now two kind of builtin attributes. The old
:prototype args are still compiled as barewords, but the new :native
and :symbol attribute args (and probably more upcoming) are compiled
as data, with constant strings being compiled at compile-time, and
scalar values being defered to run-time.  Just as with &lt;code&gt;use attributes
&amp;quot;native&amp;quot;, $libname;&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;internally&#34;&gt;Internally&lt;/h1&gt;

&lt;p&gt;Internally perl5 has 3 attrs API&amp;rsquo;s. Two of them are useful, if still broken.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;apply_attrs&lt;/code&gt; is the compile-time variant, passing the verbatim string
with the argument to the attribute import call at compile-time.&lt;/p&gt;

&lt;p&gt;This translates &lt;code&gt;sub func :native($libname)&lt;/code&gt; to
&lt;code&gt;BEGIN { use attributes __PACKAGE__, \&amp;amp;func, &#39;native($libname)&#39;; }&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;apply_attrs_my&lt;/code&gt; is the run-time variant, passing the verbatim string
with the argument to the attribute import call at run-time.&lt;/p&gt;

&lt;p&gt;This translates &lt;code&gt;my $var :native($libname);&lt;/code&gt; to &lt;code&gt;my $var; use
attributes __PACKAGE__, \&amp;amp;var, &#39;native($libname);&lt;/code&gt;.  This is almost
correct. At least the import is done at run-time, and the attribute
handler will have a chance to handle the value of the thing inside the
parens. So eval will work there.&lt;/p&gt;

&lt;p&gt;cperl detects in the lexer scalar variables from attribute arguments,
constructs a proper list for the argument,
and passes it to &lt;code&gt;apply_attrs()&lt;/code&gt;, which then tries to detect needed
run-time deferral. And if so calls &lt;code&gt;apply_attrs_my()&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;This translates &lt;code&gt;my $var :native($libname);&lt;/code&gt; to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $var; use attributes __PACKAGE__, \$var, &#39;native&#39;, $libname;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And &lt;code&gt;sub func :native($libname);&lt;/code&gt; to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub func; use attributes __PACKAGE__, \&amp;amp;func, &#39;native&#39;, $libname;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third internal API &lt;code&gt;apply_attrs_string&lt;/code&gt; is extremely naive and
only useful to process simple &lt;code&gt;ATTRS:&lt;/code&gt; token in XS declarations. It
cannot handle utf8, and splits arguments by space, not being able to
handle nested parens. And then it calls the importer at compile-time.&lt;/p&gt;

&lt;p&gt;In cperl I added an &lt;code&gt;attrs_runtime()&lt;/code&gt; API, which looks at the list of
attrs from the lexer, and calls the runtime variant &lt;code&gt;apply_attrs_my&lt;/code&gt; when
a scalar variable or function call is detected.&lt;/p&gt;

&lt;p&gt;So far I treat :native and :symbol barewords as constant strings and
not as function calls.
I.e. &lt;code&gt;:native(mysqlclient)&lt;/code&gt; does not call the mysqlclient function to return the name.
Attribute::Handler would do that. I&amp;rsquo;ll probably add that with the more explicit
&lt;code&gt;:native(&amp;amp;mysqlclient)&lt;/code&gt; syntax.&lt;/p&gt;

&lt;h1 id=&#34;why-attributes&#34;&gt;Why attributes?&lt;/h1&gt;

&lt;p&gt;A better idea than attributes to attach data would have been metadata
as methods, because then you could also query the current values. With
attributes you can only set it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\&amp;amp;mysql_ffi_fetch-&amp;gt;NATIVE = &amp;quot;mysqlclient.6.so&amp;quot;;
print \&amp;amp;mysql_ffi_fetch-&amp;gt;NATIVE, \&amp;amp;mysql_ffi_fetch-&amp;gt;SYMBOL;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would be independent of packages, and much easier than with
package specific &lt;code&gt;FETCH_CODE_ATTRIBUTES&lt;/code&gt; hooks. You just query the
data. And the magic method would be &lt;strong&gt;lvalue&lt;/strong&gt;, so it could be used as
getter and setter.&lt;/p&gt;

&lt;p&gt;But for compatibility with other languages attributes do make a fine
syntax to declare data properties. So cperl will continue to use the perl5
attribute syntax for perl6 &lt;code&gt;traits&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;see-also&#34;&gt;See also&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/perl11/cperl/issues/22&#34;&gt;ffi #22&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/perl11/cperl/issues/291&#34;&gt;Resolve core attribute arguments, runtime setters, safely #291&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/perl11/cperl/commits/feature/gh22-ffi&#34;&gt;feature/gh22-ffi branch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-6bvokz-attributes-args&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/6bvokz/attributes-args/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>strict names</title>
      <link>http://perl11.org/blog/strict-names.html</link>
      <pubDate>Thu, 18 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/strict-names.html</guid>
      <description>

&lt;h1 id=&#34;consistent-identifier-parsing-rules&#34;&gt;Consistent identifier parsing rules&lt;/h1&gt;

&lt;p&gt;perl5 and cperl older than 5.27.0 accepts any string as valid
identifier name when being created under &lt;code&gt;no strict &#39;refs&#39;&lt;/code&gt; at
run-time, even when most such names are illegal, and cannot be handled
by most external modules.
Even invalid unicode is allowed.&lt;/p&gt;

&lt;p&gt;cperl 5.26 fixed embedded NUL&amp;rsquo;s and invalid unicode
identifiers &lt;a href=&#34;https://github.com/perl11/cperl/issues/233&#34;&gt;illegal&lt;/a&gt;,
and
&lt;a href=&#34;https://github.com/perl11/cperl/issues/228&#34;&gt;normalizes unicode identifiers&lt;/a&gt; in
the parser.&lt;/p&gt;

&lt;p&gt;Since cperl 5.27.1 dynamically created names are treated the same way
as when they are parsed. Which means illegal utf8 names are
rejected, unicode names are now normalized at run-time in the rv2sv
OP, via &lt;code&gt;${&amp;quot;string&amp;quot;}&lt;/code&gt; and mixed unicode scripts are also checked.&lt;/p&gt;

&lt;h1 id=&#34;strict-names&#34;&gt;strict names&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;strict &amp;lsquo;names&amp;rsquo;&lt;/strong&gt; is now implemented, included in the default and
enabled with cperl 5.27.1. It checks
for &lt;a href=&#34;http://perl11.org/cperl/perldata.html#Identifier-parsing&#34;&gt;valid identifiers&lt;/a&gt; being
created from strings under &lt;code&gt;no strict &#39;refs&#39;&lt;/code&gt; at run-time to match the
same rules as when they would have been created at compile-time by the
parser. Which helps
in &lt;a href=&#34;unicode-identifiers.html&#34;&gt;fighting invalid identifiers&lt;/a&gt;, which
cannot be handled by the rest of perl.
There was still room left to create invalid and
potentially harmful utf8 or binary names at run-time via &lt;code&gt;no strict &#39;refs&#39;&lt;/code&gt;.
strict names ensures no illegal name will get created.&lt;/p&gt;

&lt;p&gt;Note that p5p insists that illegal identifiers are still legal to
create at run-time. Only compile-time illegal identifiers are illegal.&lt;/p&gt;

&lt;p&gt;Currently it clashes with a reserved VMS hint. That means on VMS
strict names will be implemented in a slower way, via a hints hash
key, not a hints scalar bit.&lt;/p&gt;

&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;This was legal before and is now illegal:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    use strict; no strict &#39;refs&#39;;

    ${&amp;quot;\xc3\x28&amp;quot;}
    
    my $s = &amp;quot;\xe2\x28\xa1&amp;quot;;
    ${$s}
    
    ${&amp;quot;$s\::xx&amp;quot;}
    
    ${&amp;quot;\cTAINT&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=&amp;gt; Invalid identifier &amp;ldquo;\24AINT&amp;rdquo; while &amp;ldquo;strict names&amp;rdquo; in use&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This symbol is since 5.26 normalized, previously not.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    use strict; no strict &amp;quot;refs&amp;quot;;
    my $cafÃ© = &amp;quot;cafeÌ&amp;quot;;   # &amp;lt;c, a, f, e, U+0301, U+0301&amp;gt;
    print $cafÃ©;         # &amp;lt;c, a, f, U+00E9&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Empty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cafeÌ
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;And the illegal UTF-8 variant:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;     use strict; no strict &#39;refs&#39;;
     my $cafeÌ = &amp;quot;cafÃ©&amp;quot;; # &amp;lt;c, a, f, e, U+0301, U+0301&amp;gt; 
     print ${$cafÃ©};    # &amp;lt;c, a, f, U+00E9&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Global symbol &amp;quot;$cafÃ©&amp;quot; requires explicit package name (did you forget to declare &amp;quot;my $cafÃ©&amp;quot;?) at -e line 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Malformed UTF-8 character: \x81 (unexpected continuation byte 0x81, with no preceding start byte) in scalar dereference at -e line 3.
Malformed UTF-8 character (fatal) at -e line 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;cpan-impact&#34;&gt;CPAN Impact&lt;/h1&gt;

&lt;p&gt;Not many CPAN modules are affected by strict names being on by
default.  This is expected as strict names mostly protects against
run-time security attacks.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pod-Perldoc: &lt;a href=&#34;https://rt.cpan.org/Ticket/Display.html?id=121771&#34;&gt;https://rt.cpan.org/Ticket/Display.html?id=121771&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;my $version = do { no strict &#39;refs&#39;; ${ &#39;$&#39; . $class . &#39;::VERSION&#39; } };&lt;/code&gt;
=&amp;gt; Invalid identifier &amp;ldquo;$Pod::Perldoc::VERSION&amp;rdquo; while &amp;ldquo;strict names&amp;rdquo; in use&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cperl caught the wrong leading &lt;code&gt;$&lt;/code&gt; here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Scalar-List-Utils: tests for binary names without &lt;code&gt;no strict&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PathTools: File::Spec::Unix&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    my $taint = do { no strict; ${&amp;quot;\cTAINT&amp;quot;} };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default package &lt;code&gt;%main::&lt;/code&gt; is not detected yet with
&lt;code&gt;valid_ident()&lt;/code&gt;, so this fails under strict names, but would pass with
&lt;code&gt;${&amp;quot;::\cTAINT&amp;quot;}&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;EUMM: ExtUtils::MakeMaker::Locale&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Encode::Alias::define_alias(sub {
    no strict; # no strict names: &amp;quot;-&amp;quot; is an invalid IDCont
    no warnings &#39;once&#39;;
    return ${&amp;quot;ENCODING_&amp;quot; . uc(shift)};
}, &amp;quot;locale&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$ENCODING_UTF-8&lt;/code&gt; is an invalid identifier. So don&amp;rsquo;t use strict names.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-6bvokz-strict-names&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/6bvokz/strict_names/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>strict hashpairs</title>
      <link>http://perl11.org/blog/strict-hashpairs.html</link>
      <pubDate>Tue, 16 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/strict-hashpairs.html</guid>
      <description>

&lt;h1 id=&#34;perl5-optionally-warns-on-odd-hash-elements&#34;&gt;perl5 optionally warns on odd hash elements&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;my %h = (0,1,2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is legal code in perl5. The second pair is constructed with the undef value.
With &lt;code&gt;use warnings &#39;misc&#39;&lt;/code&gt; it will warn at least.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use warnings;
my %h = (0,1,2);
=&amp;gt; Odd number of elements in hash assignment (WARNING only)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;perl6-throws-on-odd-hash-elements&#34;&gt;perl6 throws on odd hash elements&lt;/h1&gt;

&lt;p&gt;perl6 is sane and strict by default.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %h = (0..2);
=&amp;gt; Odd number of elements found where hash initializer expected:
Found 3 (implicit) elements:
Last element seen: 2
  in block &amp;lt;unit&amp;gt; at &amp;lt;unknown file&amp;gt; line 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;cperl-5-27-throws-with-use-strict&#34;&gt;cperl 5.27 throws with use strict&lt;/h1&gt;

&lt;p&gt;Since cperl 5.27.0 use strict added two new keys: &lt;strong&gt;&amp;lsquo;hashpairs&amp;rsquo;&lt;/strong&gt; and
&amp;lsquo;names&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;strict hashpairs ensure that no hashes can get created from lists or arrays with odd elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use strict;
my %h = (0,1,2);
=&amp;gt; Only pairs in hash assignment allowed while &amp;quot;strict hashpairs&amp;quot;, got 3 elements
Execution of -e aborted due to compilation errors
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With constant arrays or lists this is even a compile-time error, as seen above.&lt;/p&gt;

&lt;p&gt;With map it is even more strict. With map only a missing or a single
pair is allowed to construct a hash, not multiple pairs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use strict;
my %h = map {$_=&amp;gt;1, $_+1} (0..2);
=&amp;gt; Only pair in map hash assignment allowed while &amp;quot;strict hashpairs&amp;quot;, got 3 elements
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was legal in perl5 and is now a run-time error. Net::DNS did it
to construct two pairs in one loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use strict;
my %h = map {$_} @array;
=&amp;gt; Only pair in map hash assignment allowed while &amp;quot;strict hashpairs&amp;quot;, got 1 elements
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Typical oddities, which are now forbidden:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%h = map { $ =&amp;gt; (0,1) } (0..3);
=&amp;gt; 1=&amp;gt;3, 2=&amp;gt;0, 0=&amp;gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only 3 keys, not 4. Because &lt;code&gt;@h=map{$=&amp;gt;(0,1)}(0..3);print join&amp;quot; &amp;quot;,@h&#39;&lt;/code&gt;
=&amp;gt; &lt;code&gt;0 0 1 1 0 1 2 0 1 3 0 1&lt;/code&gt; and the duplicate keys collapse.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%h = map { $_ } (0..3);
=&amp;gt; 2=&amp;gt;3, 0=&amp;gt;1 (2 keys, of course)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;more-warnings&#34;&gt;More warnings&lt;/h1&gt;

&lt;p&gt;cperl 5.27 added detection for more &amp;ldquo;Odd elements&amp;rdquo; warnings, esp.
when a map assigned to a hash produces no pairs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;no strict;
use warnings;
%h = map { $_ } (0..1);
# =&amp;gt; Odd number of map elements in hash assignment
%h = map { $_ =&amp;gt; (0,1) } (0..1);
# =&amp;gt; Odd number of map elements in hash assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The warning is only produced once for each map, not for every map iteration.&lt;/p&gt;

&lt;h1 id=&#34;cpan-impact&#34;&gt;CPAN Impact&lt;/h1&gt;

&lt;p&gt;One might think changing the strictness of the language might break a lot of modules.
Thanksfully most module authors already use sane coding principles, only a few
produce multiple pairs per map to a hash.&lt;/p&gt;

&lt;p&gt;All of them have been fixed in my distroprefs patches, and some also upstream.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Net-NDS: &lt;a href=&#34;https://rt.cpan.org/Ticket/Display.html?id=121680&#34;&gt;https://rt.cpan.org/Ticket/Display.html?id=121680&lt;/a&gt; &lt;a href=&#34;https://github.com/rurban/distroprefs/commit/63cd16b8359d1ccd062f0c4b913fa77b4b8681ff&#34;&gt;rurban/distroprefs@63cd16b&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Moose: &lt;a href=&#34;https://github.com/rurban/distroprefs/commit/f929f794fc64b5fef3b29c81f5b313c28f60da92&#34;&gt;rurban/distroprefs@f929f79&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DBI: &lt;a href=&#34;https://github.com/rurban/distroprefs/commit/2f0c82d7e938e8d10420c3d76eab235fbb229fff&#34;&gt;rurban/distroprefs@2f0c82d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Class::Tiny &lt;a href=&#34;https://github.com/rurban/distroprefs/commit/02054335a9c30aa3d5d7abfe7ca6002d5ccd4033&#34;&gt;rurban/distroprefs@0205433&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MooseX::Types &lt;a href=&#34;https://github.com/rurban/distroprefs/commit/e1e3fc0fc6f03a6dcc6afdf9afd4ac85abd6076a&#34;&gt;rurban/distroprefs@e1e3fc0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Encode &lt;a href=&#34;https://github.com/dankogai/p5-encode/pull/100&#34;&gt;dankogai/p5-encode#100&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Only one module at all used a double pair in a map, Net::DNS. This was easily fixed.
The other modules use &lt;code&gt;%opts = @_;&lt;/code&gt; to assign a hash from the pairwise arguments of a
subroutine call. Perfectly fine usage.&lt;/p&gt;

&lt;p&gt;It get&amp;rsquo;s crazy with something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %p = map { %{$_} } @_;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in &lt;code&gt;Moose/Util/TypeConstraints.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %attrs = map { %{ Class::MOP::Class-&amp;gt;initialize($_)-&amp;gt;_attribute_map } }
            reverse $self-&amp;gt;linearized_isa;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in &lt;code&gt;Class/MOP/Class.pm&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %defaults = map { ref $_ eq &#39;HASH&#39; ? %$_ : ( $_ =&amp;gt; undef ) } @spec;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in &lt;code&gt;Class/Tiny.pm&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %order = map {
            my $order = $_;
            map { ( $_ =&amp;gt; $order ) } @{ $dbh-&amp;gt;{sql_init_order}{$order} };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in DBI. Here you also see the manual prevention of the problem described
below, protecting the iteration key from the global iterator in nested
map loops.&lt;/p&gt;

&lt;p&gt;These cases just deserve a &lt;code&gt;no strict &amp;quot;hashpairs&amp;quot;&lt;/code&gt; or fix it.&lt;/p&gt;

&lt;p&gt;The typical hackish workaround for such cases is constructing a
temp. @array from the map and then assign the hash from this array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %p = map { %{$_} } @_;

=&amp;gt;

my @p = map { %{$_} } @_;
my %p = @p;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sideeffects-and-wrong-order-of-evaluation-in-map&#34;&gt;Sideeffects and wrong order of evaluation in map&lt;/h1&gt;

&lt;p&gt;And now look at these oddities, detected by Patrick Cronin and rafl for their
new &lt;a href=&#34;https://github.com/PatrickCronin/Map-Functional/&#34;&gt;Map::Functional&lt;/a&gt;
module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub x{$_,&amp;quot;ouch&amp;quot;}; %h = map { $_ =&amp;gt; x } (0..3);
=&amp;gt; %h =&amp;gt; 3=&amp;gt;ouch, ouch=&amp;gt;3, 1=&amp;gt;ouch, 2=&amp;gt;2, 0=&amp;gt;0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5 not 4 keys. Still the normal list comprehension problem..
But what if the value changes the key?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub x{$_ = &amp;quot;ouch&amp;quot;}; %h = map { $_ =&amp;gt; x } (0..3);
=&amp;gt; %h =&amp;gt; ouch=&amp;gt;ouch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A sideffect in the value evaluation changed the key, because the &lt;code&gt;$_&lt;/code&gt;
inside the x subroutine is the same as the global &lt;code&gt;$_&lt;/code&gt; loop iterator
inside map.  They experience problems with the global topic trampled
over inside a loop by various other ops, just as &lt;code&gt;while (&amp;lt;&amp;gt;){}&lt;/code&gt; called from
the value, which changed the key.&lt;/p&gt;

&lt;p&gt;Too bad &lt;a href=&#34;http://blogs.perl.org/users/rurban/2016/04/the-removal-of-the-lexical-topic-feature-in-524.html&#34;&gt;perl5 removed the lexical &lt;code&gt;$_&lt;/code&gt; topic&lt;/a&gt;. This
would at least have saved the loop iterator.&lt;/p&gt;

&lt;p&gt;But it is worse than that. It is even broken without a lexical &lt;code&gt;$_&lt;/code&gt;,
and without a function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%h = map { $_ =&amp;gt; ($_ = &amp;quot;ouch&amp;quot;) } (0..3);
=&amp;gt; %h =&amp;gt; ouch=&amp;gt;ouch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the values inside the map are computed at once, hence the first
&lt;code&gt;$_&lt;/code&gt; is changed also, and the list produced by the map block is
consumed later, when the block is done.  In a proper language with
proper of left to right evaluation order the key would be consumed
first, and then the value.&lt;/p&gt;

&lt;p&gt;The underlying design problem is that the map lambda has no formal argument
list, where you could enforce that order. &lt;code&gt;map sub(a,b){ a =&amp;gt; b } (0..3)&lt;/code&gt;
perl5 just uses a block body with a silent &lt;code&gt;($_)&lt;/code&gt; lambda
signature and the return value(s) just spill over to the stack.&lt;/p&gt;

&lt;p&gt;But it is still solvable by detecting lists inside map blocks and
consume them one by one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;map { $_ =&amp;gt; ($_ = &amp;quot;ouch&amp;quot;) } (0..3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is roughly compiled as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapstart { stmt, stmt } mapwhile rv2av const(AV)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I might change it to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapstart { stmt; mapwhile; stmt } mapwhile rv2av const(AV)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The embedded mapwhile op would consume the first element, push it into
the stack and continue. This would make hash assignments via map much safer.&lt;/p&gt;

&lt;h1 id=&#34;strict-names&#34;&gt;strict names&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;strict &amp;lsquo;names&amp;rsquo;&lt;/strong&gt; is not yet enabled. It will check for valid
identifiers being created from strings under no strict &amp;lsquo;refs&amp;rsquo;. Which
helps in &lt;a href=&#34;unicode-identifiers.html&#34;&gt;fighting invalid identifiers&lt;/a&gt;
being created, which cannot be handled by the rest of perl, and
esp. since 5.16 with additional embedded NUL.  cperl 5.26 made
embedded NUL&amp;rsquo;s and invalid unicode
identifiers &lt;a href=&#34;https://github.com/perl11/cperl/issues/233&#34;&gt;illegal&lt;/a&gt;,
and &lt;a href=&#34;https://github.com/perl11/cperl/issues/228&#34;&gt;normalizes unicode identifiers&lt;/a&gt;. But
there&amp;rsquo;s still room left to create invalid and potentially harmful
unicode names. Some cases are only warned against.  strict names will
ensure no illegal name will get created.&lt;/p&gt;

&lt;p&gt;And it clashes with a reserved VMS hint. Means on VMS strict names will be a no-op.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-6bgya8-strict-hashpairs&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/6bgya8/strict_hashpairs/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Automatic cperl deployments</title>
      <link>http://perl11.org/blog/automatic-deployments.html</link>
      <pubDate>Thu, 27 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/automatic-deployments.html</guid>
      <description>

&lt;h1 id=&#34;binary-packages&#34;&gt;Binary packages&lt;/h1&gt;

&lt;p&gt;perl5 relies on external packagers to update and maintain packages for
various distributions. It only provides source packages as tarballs.&lt;/p&gt;

&lt;p&gt;cperl does a bit better by also providing binary packages for all
major platforms. See also &lt;strong&gt;Installation&lt;/strong&gt; at the
&lt;a href=&#34;http://perl11.org/cperl/STATUS.html&#34;&gt;STATUS&lt;/a&gt; page.
&lt;a href=&#34;http://perl11.org/win/&#34;&gt;win32, win64&lt;/a&gt;, debian 7 i686, debian 8 amd64,
centos 7 x86_64, centos 6 i686+x86_64 and &lt;a href=&#34;http://perl11.org/osx/&#34;&gt;darwin amd64&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Packaging was done with this &lt;a href=&#34;https://github.com/perl11/cperl/blob/master/Porting/do-make-cperl-release&#34;&gt;do-make-cperl-release&lt;/a&gt; script, leading to&lt;/p&gt;

&lt;p&gt;Centos/Fedora/RHEL as el6 or el7 &lt;code&gt;/etc/yum.repos.d/perl11.repo&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[perl11]
name=perl11
baseurl=http://perl11.org/rpm/el7/$basearch
enabled=1
gpgkey=http://perl11.org/rpm/RPM-GPG-KEY-rurban
gpgcheck=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or for Debian/Ubuntu &lt;code&gt;/etc/apt/sources.list.d/perl11.list&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://perl11.org/deb/ sid main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far the packaging was done on private build VM&amp;rsquo;s, and the hosting
was done on github.  Yes, you can easily host deb and rpm distros for
free at github pages.  But the idea is also to use external package
providers, like &lt;a href=&#34;https://build.opensuse.org/&#34;&gt;OpenSUSE OBS&lt;/a&gt;
or &lt;a href=&#34;https://bintray.com/perl11/&#34;&gt;Bintray&lt;/a&gt;, which do packaging and
hosting for many more platforms.&lt;/p&gt;

&lt;h1 id=&#34;autodeploy&#34;&gt;Autodeploy&lt;/h1&gt;

&lt;p&gt;With cperl-5.26.0c the packaging for at least win32 and the new win64
platforms with MSVC12 and darwin is done automatically via tagging a release and pushing it
to &lt;a href=&#34;https://github.com/perl11/cperl/releases&#34;&gt;github&lt;/a&gt;.
For MSVC12 you&amp;rsquo;ll need the &lt;em&gt;msvcr120.dll&lt;/em&gt; runtime,
available e.g. from the Microsoft VS 2013 C++ Redistributable Package
from &lt;a href=&#34;https://www.microsoft.com/en-us/download/details.aspx?id=40784&#34;&gt;https://www.microsoft.com/en-us/download/details.aspx?id=40784&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&#34;https://github.com/perl11/cperl/commit/9a79df78a29fb50a3c2837cdd2a8422fe98b760a&#34;&gt;today&lt;/a&gt; appveyor provides the windows deployments, and &lt;a href=&#34;https://travis-ci.org/perl11/cperl/builds&#34;&gt;travis&lt;/a&gt; the linux src tarballs and darwin deployments.&lt;/p&gt;

&lt;p&gt;Additionally &lt;a href=&#34;https://ci.appveyor.com/project/rurban/cperl/history&#34;&gt;appveyor&lt;/a&gt;
provides also nightly builds on every master change. This is for now
only in private draft releases, but I&amp;rsquo;ll think about enabling it as
pre-releases.&lt;/p&gt;

&lt;p&gt;Travis does not support nightly builds as easy as Appveyor.
With Appveyor you can tag your deployments as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;draft: true
prerelease: true
force_update: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but with Travis you can only deploy tags. So for a nightly you would need to add a
tag for every master change, there&amp;rsquo;s no deploy condition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on:
  appveyor_repo_tag: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on:
  branch: /(master|relprep)/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The missing &lt;code&gt;prerelease&lt;/code&gt; or &lt;code&gt;draft&lt;/code&gt; tag on Travis also means that
every deployment on tags is a proper release, and you have to manually
change that to a &lt;em&gt;Pre-Release&lt;/em&gt; on the github release page. You cannot
change that to an invisible &lt;em&gt;Draft&lt;/em&gt; release.&lt;/p&gt;

&lt;p&gt;The Appveyor &lt;code&gt;force_update: true&lt;/code&gt; deploy tag means that you can start
a deployment from win32/msvc12 and add files from e.g. win64 later to
that github release. Travis always allows that. E.g. the src tarballs
are added first and darwin pkgbuild files are added later.&lt;/p&gt;

&lt;p&gt;One could also think of extending that to CPAN uploads, by encrypting the PAUSE key
and let Travis-CI trigger the cpan upload on every new release tag.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unicode Identifiers</title>
      <link>http://perl11.org/blog/unicode-identifiers.html</link>
      <pubDate>Tue, 07 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/unicode-identifiers.html</guid>
      <description>

&lt;h1 id=&#34;binary-names-with-5-16&#34;&gt;Binary names with 5.16&lt;/h1&gt;

&lt;p&gt;With perl 5.16 added support for binary names, announcing it as
support for unicode names. Unicode names were already supported since
5.8.4 with a negative length stored in the hash key of the symbol.&lt;/p&gt;

&lt;p&gt;Supporting binary names without any supporting measures opened huge
security holes, as names are mapped 1:1 to filenames when searching
for a package, and as we know the C API for files or names just
ignores a \0, leading to inconsistencies. And you could now easily
hide payloads in package names. Remember that p5p never announced this
problem and feature, they only announced it as improved and full
unicode support for names.  In the following years I had to fix most
of the problems with binary names support, but many critical modules
still have no idea, and are still vulnerable. Even the new perl5
maintainer has no idea as he showed in his YAPC talk about XS
programming. He happily used the old &lt;code&gt;gv_&lt;/code&gt; interfaces not supporting
\0, and there&amp;rsquo;s no upgrade path in perl5 for old modules to avoid those
security holes.&lt;/p&gt;

&lt;p&gt;Well, with unicode this would not have been a big problem, as our used
encoding UTF-8 does not support \0. It&amp;rsquo;s also illegal.
Only with cperl-5.26 we finally got back safe names, \0 is illegal again.&lt;/p&gt;

&lt;h1 id=&#34;unicode-security&#34;&gt;Unicode Security&lt;/h1&gt;

&lt;p&gt;But here we want to talk about the unicode problems when a language
decides to embrace unicode names. perl5 prides itself by being one of
the scripting languages with the best unicode support.  Well, the
libraries and strings, yes. But the language itself is still horribly
unicode unsafe.&lt;/p&gt;

&lt;p&gt;The unicode consortium published many security addendums, as TRnn.
Most of them are targetted to html forms, domains names used in
browsers or DNS servers, and email names. The problem with unicode is,
that different names are not identifiable as such, and thus you can
easily fool someone to click on a wrong url. Identifiers need to be
identifiable and restricted.  perl5 and perl6 pride themselves of
anything goes, it does not enforce opinions on their users. Well, it&amp;rsquo;s
still insecure.&lt;/p&gt;

&lt;p&gt;The simpliest unicode problems are tricks with illegal UTF-8
encodings.  This is also relevant to strings and therefore mostly
fixed in perl5 and cperl.&lt;/p&gt;

&lt;p&gt;But there are many more security problems in most programming
languages with unicode support. Only cperl, python3 and perl6 fixed
some of them, by doing normalization of its identifiers.
I didn&amp;rsquo;t see any effort in all the others, besides java.&lt;/p&gt;

&lt;p&gt;The most basic overview is at &lt;a href=&#34;http://websec.github.io/unicode-security-guide/&#34;&gt;http://websec.github.io/unicode-security-guide/&lt;/a&gt;.
Go read it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Because Unicode contains such a large number of characters and
 incorporates the varied writing systems of the world, incorrect usage
 can expose programs or systems to possible security attacks. This is
 especially important as more and more products are
 internationalized. This document describes some of the security
 considerations that programmers, system analysts, standards
 developers, and users should take into account, and provides specific
 recommendations to reduce the risk of problems.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The most important documents are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers&#34;&gt;TR31 Candidate Characters for Exclusion from Identifiers&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr36/&#34;&gt;TR36 Unicode Security Considerations&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr39/&#34;&gt;TR39 Unicode Security Mechanisms&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In short, those problems need to be fixed:&lt;/p&gt;

&lt;h1 id=&#34;mixed-scripts&#34;&gt;Mixed scripts&lt;/h1&gt;

&lt;p&gt;A written language is defined by its scripts (i.e. &amp;ldquo;alphabets&amp;rdquo;). Some
languages allow multiple scripts, such as modern Japanese uses both
logographic (kanji, originated from Chinese hanzi&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;) and syllabic
(kana) characters simultaneously, with two distinct types of kana
(hiragana and katakana).  So if you want to support japanese you need
allow all these three scripts to be used in a program, without any
declaration. Similar for Korean, which sometimes also use some old
Han/Chinese characters, and Chinese which uses the biggest set of
characters Han, plus one additional educational script, called
Bopomofo.&lt;/p&gt;

&lt;p&gt;The problem is very apparent with Cyrillic and Greek. Both are
different languages, but use almost the same characters, which are not
identifiable in any font. If the character is a Greek or Cyrillic
symbol, or if it&amp;rsquo;s one of the mathematical symbols.&lt;/p&gt;

&lt;p&gt;So strict mixed-script profiles for identifiers forbid the default
usage of Greek and Cyrillic characters in the same program.&lt;/p&gt;

&lt;p&gt;In cperl, which is currently the only unicode safe language, this
is forbidden:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8;
my $Î = 1;
if ($Ð) { warn; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;use utf8&lt;/code&gt; declares that identifiers can be unicode, utf-8 encoded.
&lt;code&gt;my $Î = 1&lt;/code&gt; sets a scalar lexical variable to 1, with the name &lt;code&gt;Î&lt;/code&gt;.
What you don&amp;rsquo;t see, only the parser, or if you inspect the program
binary, e.g. with od, is that the first Î character is the greek
gamma, and the second variable uses the cyrillic gamma.
Only with a restricted identifier profile you will see the problem.&lt;/p&gt;

&lt;p&gt;cperl does this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cperl5.26.0 -e&#39;use utf8;my $Î = 1;if ($Ð) { warn }&#39;
Invalid script Cyrillic in identifier Ð) { warn }
for U+0413. Have Greek at -e line 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I.e. it allows the first greek character in a name to be used without
declaration of a foreign script, but then fails when a cyrillic
character in a name appears. With such characters in strings or
buffers the user has to care, but with identifiers the parser has to
care, as the identifier is not identifiable anymore.&lt;/p&gt;

&lt;p&gt;When a user really wants to use names in multiple languages in a
program, he needs to declare them beforehand, so the casual reader is
aware of the mixed scripts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8 (&amp;quot;Greek&amp;quot;, &amp;quot;Cyrillic&amp;quot;);
my $Î = 1;
if ($Ð) { warn }&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is now a somewhat valid variant. But note that mixing Cyrillic and
Greek is still frowned upon, and needs to be warned, even when being
declared as such.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=&amp;gt; Invalid script Cyrillic, cannot be mixed with Greek
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarily, some scripts can be used undeclared, and some need to be
declared.  These recommendations are all specified in the TR39
Restriction levels.&lt;/p&gt;

&lt;h1 id=&#34;visual-spoofing&#34;&gt;Visual spoofing&lt;/h1&gt;

&lt;p&gt;Unicode is pretty good in defining what characters are allowed as
first character in an identifier, and what characters may
follow. These classes are declared in the &lt;code&gt;ID_Start&lt;/code&gt; and
&lt;code&gt;ID_Continue&lt;/code&gt;, see
&lt;a href=&#34;http://www.unicode.org/reports/tr31/#Table_Lexical_Classes_for_Identifiers&#34;&gt;TR 31 Lexical_Classes_for_Identifiers&lt;/a&gt;
for the precise rules properly used in most languages with unicode
support.&lt;/p&gt;

&lt;p&gt;I know only of one bug in these tables, the U+3164 HANGUL FILLER is
wrongly specified as ID_Cont. Thus in perl5 this is valid:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -e&#39;use utf8; $aã¤b == 2;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but cperl detects the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cperl -e&#39;use utf8; $aã¤b == 2;&#39;
Unrecognized character \x{3164}; marked by &amp;lt;-- HERE after e utf8; $a&amp;lt;-- HERE
near column 13 at -e line 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same problem for the U+ffa0 HALFWIDTH HANGUL FILLER. See also
&lt;a href=&#34;https://github.com/jagracey/Awesome-Unicode#user-content-variable-identifiers-can-effectively-include-whitespace&#34;&gt;https://github.com/jagracey/Awesome-Unicode#user-content-variable-identifiers-can-effectively-include-whitespace&lt;/a&gt;
According to according to
&lt;a href=&#34;http://www.unicode.org/L2/L2006/06310-hangul-decompose9.pdf&#34;&gt;http://www.unicode.org/L2/L2006/06310-hangul-decompose9.pdf&lt;/a&gt; those two
fillers á..á  HANGUL CHOSEONG FILLER..HANGUL JUNGSEONG FILLER are the
proper replacements.&lt;/p&gt;

&lt;p&gt;But besides those rare bugs, spoofs and confusables are much more common.
I only know of very few languages which actually detect those problems.&lt;/p&gt;

&lt;p&gt;Spoofs are certain trick character combinations.&lt;/p&gt;

&lt;p&gt;Popular spoof attacks were the Paypal.com IDN spoof of 2005. Setup to
demonstrate the power of these attack vectors, Eric Johanson and The
Schmoo Group successfully used a www.paypal.com lookalike domain name
to fool visitors into providing personal information. The advisory
references original research from 2002 by Evgeniy Gabrilovich and Alex
Gontmakher at the Israel Institute of Technology. Their original paper
described an attack using Microsoft.com as an example. - &lt;a href=&#34;http://websec.github.io/unicode-security-guide/visual-spoofing/&#34;&gt;visual-spoofing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A typical bidi-spoof would involve a unicode aware text-editor or
viewer, and identifiers which switch to right-to-left (arabic),
overwrite the previous characters, and maybe even switch back to
left-to-right. Visually the names look the same, but internally the
spoofed name is much longer.&lt;/p&gt;

&lt;p&gt;Such spoofs are usually prevented with forbidding mixed scripts.&lt;/p&gt;

&lt;h1 id=&#34;normalization&#34;&gt;Normalization&lt;/h1&gt;

&lt;p&gt;Other simple spoofs can be be prevented with normalization. This is
what Python3 started to do, also cperl and java.  With normalization
of unicode character sequences all possible and valid character
combinations are compressed to one single normal form. There are two
defined normal forms, NFKC and NFC, interestingly python decided to
pick the wrong one, normalizing to ligatures. cperl normalizes to the
canonical normal form NFC. perl6 decided to normalize to their own
format, called NFD, which allows invalid, private reserved characters
in upper planes, which will be forbidden in upcoming perl5 and cperl
releases.&lt;/p&gt;

&lt;p&gt;E.g. &lt;code&gt;cafeÌ&lt;/code&gt; (&lt;code&gt;&amp;lt;c, a, f, e, U+0301&amp;gt;&lt;/code&gt;) is normalized to &lt;code&gt;cafÃ©&lt;/code&gt;
&lt;code&gt;&amp;lt;c, a, f, U+00E9&amp;gt;&lt;/code&gt;.
&lt;code&gt;cafeÌÌ&lt;/code&gt;, using two combining marks (&lt;code&gt;&amp;lt;c, a, f, e, U+0301, U+0301&amp;gt;&lt;/code&gt;) is currently allowed.&lt;/p&gt;

&lt;h1 id=&#34;same-script-confusables&#34;&gt;Same Script Confusables&lt;/h1&gt;

&lt;p&gt;There&amp;rsquo;s a whole table of confusables which are still confusable after
restricting mixed scripts and after normalization.
These confusables are typically optionally warned upon.&lt;/p&gt;

&lt;h1 id=&#34;moderately-restrictive-level&#34;&gt;Moderately Restrictive Level&lt;/h1&gt;

&lt;p&gt;cperl as first dynamic scripting language follows the &lt;strong&gt;General
Security Profile&lt;/strong&gt; for identifiers in programming languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Moderately Restrictive&lt;/strong&gt;: Allow &lt;code&gt;Latin&lt;/code&gt; with other Recommended or
Aspirational scripts except &lt;code&gt;Cyrillic&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt;. Otherwise, the same as
&lt;a href=&#34;http://www.unicode.org/reports/tr39/#Identifier_Characters&#34;&gt;Highly Restrictive&lt;/a&gt;,
i.e. allow &lt;code&gt;:Japanese&lt;/code&gt;, &lt;code&gt;:Korean&lt;/code&gt; and &lt;code&gt;:Hanb&lt;/code&gt; aliases.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Some characters are not in modern customary use, and thus implementations
may want to exclude them from identifiers.  These include characters in
historic and obsolete scripts, scripts used mostly liturgically, and
regional scripts used only in very small communities or with very limited
current usage.  The set of characters in Table 4, Candidate Characters for
Exclusion from Identifiers provides candidates of these.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;cperl honors the
&lt;a href=&#34;http://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers&#34;&gt;TR31 Candidate Characters for Exclusion from Identifiers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I.e. You may still declare those scripts as valid, but they are not
automatically allowed, similar to the need to declare mixed scripts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8;
my $á­ = 1; # \x{1b45} BALINESE LETTER KAF SASAK

=&amp;gt; Invalid script Balinese in identifier á­ for U+1B45
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but when declared as such:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use utf8 &#39;Balinese&#39;;
my $á­ = 1; # \x{1b45} BALINESE LETTER KAF SASAK
print &amp;quot;ok&amp;quot;;

=&amp;gt; ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The scripts listed at &amp;ldquo;Table 6, Aspirational Use Scripts&amp;rdquo;:
&lt;code&gt;Canadian_Aboriginal&lt;/code&gt;, &lt;code&gt;Miao&lt;/code&gt;, &lt;code&gt;Mongolian&lt;/code&gt;, &lt;code&gt;Tifinagh&lt;/code&gt; and &lt;code&gt;Yi&lt;/code&gt;
are included, i.e. need not to be declared.&lt;/p&gt;

&lt;p&gt;With this restriction we are close to the implementation of the
Moderately Restrictive level for identifiers by default. See
&lt;a href=&#34;http://www.unicode.org/reports/tr39/#General_Security_Profile&#34;&gt;http://www.unicode.org/reports/tr39/#General_Security_Profile&lt;/a&gt; and
&lt;a href=&#34;http://www.unicode.org/reports/tr36/#Security_Levels_and_Alerts&#34;&gt;http://www.unicode.org/reports/tr36/#Security_Levels_and_Alerts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With special declarations of the used scripts you can weaken the
restriction level to &lt;strong&gt;Minimally Restrictive&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Missing for the &lt;strong&gt;Moderately Restrictive&lt;/strong&gt; level are warnings on
single-, mixed and whole-script confusables, and warnings on certain
incompatible mixed-script pairs such as &lt;strong&gt;Greek + Cyrillic&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;All utf8 encoded names are checked for wellformed-ness.&lt;/p&gt;

&lt;h1 id=&#34;comments-at-r-cperl-https-www-reddit-com-r-cperl-comments-5y063u-unicode-identifiers&#34;&gt;&lt;a href=&#34;https://www.reddit.com/r/cperl/comments/5y063u/unicode_identifiers/&#34;&gt;Comments at /r/cperl/&lt;/a&gt;&lt;/h1&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;In Unicode, they&amp;rsquo;re generally unified into a single set, via a process called &amp;ldquo;Han unification&amp;rdquo;. So, unlike Greek &amp;ldquo;Î&amp;rdquo; vs Cyrillic &amp;ldquo;Ð&amp;rdquo;, the &amp;ldquo;same&amp;rdquo; character that may even look slightly differently in Chinese vs Japanese (e.g. &amp;ldquo;æµ·&amp;rdquo;), would have a single codepoint in Unicode.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>cperl hash tables</title>
      <link>http://perl11.org/blog/cperl-hash-tables.html</link>
      <pubDate>Sat, 04 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/cperl-hash-tables.html</guid>
      <description>

&lt;h1 id=&#34;the-old-perl5-hash-table-uses&#34;&gt;The old perl5 hash table uses&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;linked lists for its collisions, with slow out-of-cache pointer
chasing and data overhead.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unsorted flags at the end, while some flags are needed for compare.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;has questionable security measures to slow down all cases. seed ok,
randomize iter maybe, but randomize the collisions and slow hash
funcs is stupid. The security should be fixed with proper collision
iteration, not by pseudo-security theatre upfront.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;no collision search abstraction. The internal implementation quirks
leaked into core and even external modules.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;four different HE types. Only one is needed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;inefficient combination of action flags. many magic hash key lookups
involve internally 3-4 hash lookups.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;was seriously broken 4 times so far.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;in-order-to-clean-up-the-mess-i-did-the-following&#34;&gt;In order to clean up the mess, I did the following&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Added multiple new hash functions, run statistics and evaluated them.
See &lt;a href=&#34;https://github.com/rurban/perl-hash-stats&#34;&gt;perl-hash-stats&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Took over maintainance of the general hash function test suite
&lt;a href=&#34;https://github.com/rurban/smhasher#smhasher&#34;&gt;smhasher&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Attempt to fix the wrong wikipedia entry about hash tables. It
prominently claims that perl5 hash tables are highly optimized, when
in fact they are highly deoptimized, and are in fact the worst and
slowest hash table implementation in existance.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Posted the results to p5p, which was ignored. A few sentences they
said made it clear, that they had no idea what they were
doing. E.g. they made fun of Donald Knuth, and of course of me
&lt;em&gt;(besides calling me an asshole once again)&lt;/em&gt;. Hinting that they
maybe should consult an independent expert sitting in the same
office didn&amp;rsquo;t help. Revising their broken implementation of hash
tables four times so far doesn&amp;rsquo;t improve trust into their abilities.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Started implementing perfect hashes, because they were needed to
speed up all the readonly hashes in core (Config, warnings, unicode
tables).  Found some interesting new results, esp. how to speed
up memcmp by &lt;a href=&#34;http://blogs.perl.org/users/rurban/2014/08/perfect-hashes-and-faster-than-memcmp.html&#34;&gt;50% - 2000%&lt;/a&gt;
with a constant string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Studied hash function and hash table security, and detected a lot of
theatre and wrong practices in most dynamic languages, but
interestingly not in the more technical-orientated important public
services, usually maintained by a single person. Apparently
community driven development in large teams is the worst,
contradicting &lt;a href=&#34;http://www.catb.org/esr/writings/cathedral-bazaar/&#34;&gt;&amp;ldquo;The Cathedral and the Bazaar&amp;rdquo;&lt;/a&gt;. I&amp;rsquo;ll have to seperate that into a new blog post. There are
many more tellsigns of community-based development agony.
Wrote brute-force and solver-based attacks. (&lt;em&gt;No, I&amp;rsquo;m not gonna publish
these&lt;/em&gt;).  So far I could only convince google to revise their
documentation.  Added hashflood testcases to cperl to test detecting
such attacks.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;cperl-hash-tables-use&#34;&gt;cperl hash tables use&lt;/h1&gt;

&lt;p&gt;â a &lt;strong&gt;fast and short hash function&lt;/strong&gt; &lt;a href=&#34;https://github.com/rurban/smhasher#smhasher&#34;&gt;FNV1A&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;â proper DoS and DDoS &lt;strong&gt;security&lt;/strong&gt; by detecting attacks, logging and
  mitigating it. Not using the slowest of all usable hash function
  SipHash, as this doesn&amp;rsquo;t really help against attacks.&lt;/p&gt;

&lt;p&gt;â &lt;code&gt;PERTURB_KEYS_TOP&lt;/code&gt; &lt;strong&gt;move-to-front&lt;/strong&gt; with a linked list is the only
  sane strategy for simple chained bucket lists with many reads.&lt;/p&gt;

&lt;p&gt;â &lt;code&gt;HV_FILL_RATE&lt;/code&gt;: try lower fill rates than 100%.
  100% is pretty insane, esp. with our bad hash funcs. Make it fast with builtin_ctz.
  &lt;a href=&#34;https://github.com/rurban/perl-hash-stats#fill-rates&#34;&gt;&lt;img src=&#34;https://github.com/rurban/perl-hash-stats/raw/master/hash-fillrate-def-FNV1A.png&#34; alt=&#34;FNV1A fill rates&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;â use &lt;code&gt;builtin_ctz&lt;/code&gt; for faster division in &lt;code&gt;DO_HSPLIT&lt;/code&gt;.
  Allow &lt;code&gt;-DHV_FILL_RATE=90&lt;/code&gt; definition. (Tested to be the best with &lt;code&gt;FNV1A&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;â extract uncommon magical code in hot code to an extra static
  function to help keep the icache smaller. only in rare cases this
  branch is taken. (i.e filling ENV at startup). Measured 2-15% faster
  with normal scripts, not using tied hashes.&lt;/p&gt;

&lt;p&gt;â fixed &lt;code&gt;-DNODEFAULT_SHAREKEYS&lt;/code&gt;, preventing every single hash lookup
  to be done twice.  First in strtab, then in the real hash.&lt;/p&gt;

&lt;p&gt;â &lt;strong&gt;pre-extend&lt;/strong&gt; the hash size to the size of the resulting hashes in many cases
  to avoid initialization splits:
  internal stashes of some known packages, internal hashes of some known size,
  fix the hash assign operator to that in user-code.&lt;/p&gt;

&lt;p&gt;and several other minor optimizations. Typically 20% faster than in perl5.&lt;/p&gt;

&lt;h1 id=&#34;cperl-is-working-on-these-improvements&#34;&gt;cperl is working on these improvements:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;abstraction of the abstract &lt;strong&gt;HE_EACH&lt;/strong&gt; collision iterator in the
&lt;a href=&#34;https://github.com/perl11/cperl/commits/feature/gh24-base-hash&#34;&gt;feature/gh24-base-hash&lt;/a&gt; branch &lt;em&gt;(stable)&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;array_he: &lt;strong&gt;abstract AHE&lt;/strong&gt;, inline parts of the HE into the
array. array_he vs ll_he. (linked list, see also the he-array
branch). array_he (&lt;code&gt;HvARRAY = AHE[]&lt;/code&gt;) can contain
&lt;code&gt;{ hent_he, hent_hash }&lt;/code&gt;. This way the hash catches 99% of all comparisons
already, and we don&amp;rsquo;t have to chase the external hek ptr, when the
hash check fails. Every HE entry is then be 2 words (128), instead
of one word (64), called AHE. The linked list still contains the old
&lt;code&gt;HE*&lt;/code&gt;, with &lt;code&gt;{ hent_next, hent_hek, hent_val }&lt;/code&gt;. This is implemented and
works fine in the
&lt;a href=&#34;https://github.com/perl11/cperl/commits/feature/gh24-hash-loop&#34;&gt;featurex/gh24-hash-loop&lt;/a&gt; branch &lt;em&gt;(stable)&lt;/em&gt;, and on top of that the &lt;a href=&#34;https://github.com/perl11/cperl/commits/feature/gh24-array_he&#34;&gt;featurex/gh24-array_he&lt;/a&gt; branch,
which is the base to most other hash tables below.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HE_ARRAY: According to
&lt;a href=&#34;http://goanna.cs.rmit.edu.au/~jz/fulltext/spire05.pdf&#34;&gt;http://goanna.cs.rmit.edu.au/~jz/fulltext/spire05.pdf&lt;/a&gt; the best for
chained hashing is currently a &lt;strong&gt;cache-friendly array of buckets&lt;/strong&gt;,
instead of a linked list. cache-friendly continuous buffer of HE&amp;rsquo;s
w/ inlined HEK (char&lt;em&gt;) + SV&lt;/em&gt; val, but no hash, no next ptr. Also for
shared he&amp;rsquo;s: PL_strtab.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/perl11/cperl/issues/102&#34;&gt;small hash type&lt;/a&gt;:
linear search in embedded array up to 7 keys. ruby, v8 and several
others measured 3-5 to be a big win, esp. for their object fields,
but we don&amp;rsquo;t even have that yet. avoid the hash init, calc and search
overhead, esp. with our overly slow hash tables.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;hash-sortbuckets: a sorted static list of collisions (up to 8, maybe
start with 3, then 8) as in the Knuth &lt;strong&gt;&amp;ldquo;ordered hash table&amp;rdquo;&lt;/strong&gt;. We will not
use that.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;khash&lt;/strong&gt;: use open addressing as everyone else. faster, less space. But
khash needs a few fixes. And we can not use that, as perl5 is not properly
abstracted to be able to use external hash tables.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;one-word-AHE&lt;/strong&gt;: As possible improvement on that on 64bit use 48bits
for the HE ptr, and 16bits of the hash to be compared first. See
&lt;a href=&#34;https://www.semanticscholar.org/paper/Fast-Dynamically-Sized-Concurrent-Hash-Table-Barnat-Rockai/ab7dd007587f411cf99bfe056639e055eff22e0c/pdf&#34;&gt;https://www.semanticscholar.org/paper/Fast-Dynamically-Sized-Concurrent-Hash-Table-Barnat-Rockai/ab7dd007587f411cf99bfe056639e055eff22e0c/pdf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;use &lt;strong&gt;robin-hood&lt;/strong&gt; as this is currently the best worse-case strategy
(being super defensive, but not so stupid to use SipHash, which adds
no benefit). With better native threading support (shared hashes)
eventually use &lt;strong&gt;leapfrog&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;compact ordered hash&lt;/strong&gt;. use an array of short indices into a compacted
array of hash/key/val entries as in PyPy and now python: &amp;ldquo;compact
ordered dict&amp;rdquo;. This saves a lot of space and only add&amp;rsquo;s one indirect
lookup into cache-friendly array. See methane/cpython#1
&lt;a href=&#34;https://mail.python.org/pipermail/python-dev/2016-September/146327.html&#34;&gt;https://mail.python.org/pipermail/python-dev/2016-September/146327.html&lt;/a&gt;
This also iterates over the hash in insertion order, which
effectively hides any attempt to get the seed over the
iterators. For attacks you need to get collision and robin-hood
reordering timings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;get rid of &lt;strong&gt;HEK_WASUTF8&lt;/strong&gt;. &amp;ldquo;There shall be only one state, not
two&amp;rdquo;. Rather fix the encoding bug (CPAN) instead.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;p5p-plans&#34;&gt;p5p plans&lt;/h1&gt;

&lt;p&gt;p5p announced that it is working on switching to an abstract vtable
for hash tables, which is similar to their idea to run-time switch
hash functions truly horrendous.  They say it is needed to abstract
readonly (i.e. perfect hashes), and maybe tied and restricted
hashes.&lt;/p&gt;

&lt;p&gt;The cost of this would be another indirection in every hash
table call, and I don&amp;rsquo;t see any benefit.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t see a cleanup of the monstrous implementation and different
types and attempts to actually improve any of the problematic issues.
As usual with p5p it will make the situation even worse, not better.&lt;/p&gt;

&lt;h1 id=&#34;conflicts&#34;&gt;Conflicts&lt;/h1&gt;

&lt;p&gt;Having worked with &lt;code&gt;PERTURB_KEYS_TOP&lt;/code&gt; move-to-front in cperl for a few
years now, there&amp;rsquo;s only one broken module Text::CVS_XS, which assumes
in one of its testcases for parse without headers that the ordering of
keys is stable when the size did not change. The fix is in my
&lt;a href=&#34;https://github.com/rurban/distroprefs/blob/master/sources/authors/id/R/RU/RURBAN/patches/Text-CSV_XS-cperl.patch&#34;&gt;distroprefs&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-5xofay-cperl-hash-tables&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/5xofay/cperl_hash_tables/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Worst perl5 bugs</title>
      <link>http://perl11.org/blog/worst-perl5-bugs.html</link>
      <pubDate>Mon, 30 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://perl11.org/blog/worst-perl5-bugs.html</guid>
      <description>

&lt;h1 id=&#34;a-small-list-of-the-worst-perl5-bugs-all-fixed-in-cperl&#34;&gt;A small list of the worst perl5 bugs, all fixed in cperl&lt;/h1&gt;

&lt;h1 id=&#34;dos&#34;&gt;DoS&lt;/h1&gt;

&lt;p&gt;It&amp;rsquo;s trivial to DoS a perl5 system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a[9223372036854]=0;
%a=(0..4294967296);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Examples for a 64bit system, but also trivial on 32bit.
It creates a huge array or hash, which runs out of memory in the VMM
subsystem which eventually kills the process.
cperl dies with &amp;ldquo;Too many elements&amp;rdquo;, here even at compile-time.&lt;/p&gt;

&lt;h1 id=&#34;no-hash-security&#34;&gt;No Hash Security&lt;/h1&gt;

&lt;p&gt;Nothing is done against the root-cause of a hash flood denial of
service attack with colliding keys, only some security theatre by
using slower hash functions and slower collision resolution
&lt;code&gt;KEY_PERTURB_RANDOM&lt;/code&gt;.  If the seed is exposed, trivially on perl5 as
it is at a fixed known address offset readable via unpack, or exposed
via the command line, there is no prevention. Only cperl is secure,
and also much faster.  See e.g. &lt;a href=&#34;https://github.com/perl11/cperl/blob/master/t/op/hashflood.t&#34;&gt;cperl &lt;code&gt;t/op/hashflood.t&lt;/code&gt;&lt;/a&gt;
Or &lt;a href=&#34;http://perl11.org/cperl/perl5241cdelta.html#Protect-and-warn-on-hash-flood-DoS&#34;&gt;perl5241cdelta/&amp;ldquo;Protect and warn on hash flood DoS&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PERL_HASH_SEED_DEBUG=1 perl -e1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pointing that out on p5p led to the developer simply ignoring it. Instead they
are working on making it even slower, but not improving the horrible implementation
and security.&lt;/p&gt;

&lt;h1 id=&#34;language-maintainance&#34;&gt;Language Maintainance&lt;/h1&gt;

&lt;h2 id=&#34;silent-integer-overwraps&#34;&gt;Silent integer overwraps&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;@a=(0,1); print $a[~1] =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;~1&lt;/code&gt; is essentially &lt;code&gt;(UV)-2&lt;/code&gt; or &lt;code&gt;0xffff_fffe&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@a=(1);print $a[18446744073709551615]&#39; =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Silent overwrap of 18446744073709551615 to -1.&lt;/p&gt;

&lt;p&gt;The same happens with overlong hash keys, they are not converted to
SVs which can hold overlong strings. Everything in the buffer after
I32 s ignored.  Or with overlong hashes, where you can create huge hashes
&amp;gt;I32 but can only iterate over the first I32 entries.&lt;/p&gt;

&lt;p&gt;With cperl the &amp;ldquo;Too many elements&amp;rdquo; error is now triggered when
accessing or extending an out of bounds array index or trying to
insert too many hash keys. This is to prevent from silent hash or
array overflows. Previously extending a hash beyond it&amp;rsquo;s capable size
was silently ignored, leading to performance degradation with overly
high fill factors and extending an array failed only on memory
exhaustion, but the signed index led to an index overflow between I32
and U32, resp.  I64 and U64.&lt;/p&gt;

&lt;p&gt;Even worse, accessing overflown unsigned array indices would silently
access the signed counterpart, indices at the end.&lt;/p&gt;

&lt;p&gt;chop/chomp only works on half of overlarge arrays.&lt;/p&gt;

&lt;p&gt;Or ~&amp;ldquo;a&amp;rdquo;x2G complement of overlarge strings, silently processing only
the half - as with overlong hash keys.&lt;/p&gt;

&lt;p&gt;There was also a smartmatch Array - CodeRef rule, which passed only over
half the array elements.  The Hash part was also wrong, but the wrong number
was not used.&lt;/p&gt;

&lt;p&gt;regex match group of &amp;gt;2GB string len.&lt;/p&gt;

&lt;p&gt;repeat count &amp;gt;2GB and don&amp;rsquo;t silently cap it at IV_MAX. Which was
at least better then silent wrap around.&lt;/p&gt;

&lt;h1 id=&#34;names&#34;&gt;Names&lt;/h1&gt;

&lt;h2 id=&#34;binary-names&#34;&gt;Binary names&lt;/h2&gt;

&lt;p&gt;Only cperl is binary safe against \0 in names, which is esp. unsafe with
package names, being mapped 1:1 to filenames.&lt;/p&gt;

&lt;h2 id=&#34;insecure-unicode-names&#34;&gt;Insecure unicode names&lt;/h2&gt;

&lt;p&gt;Unicode allows to be identifiers not identifiable, i.e. confusable
evading visual inspection of 3rd party code. Bidi spoofs can contain
right-to-left overwriting L-T-R characters, combining marks, mixed
scripts (e.g. Cyrillic and Greek), &amp;hellip;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a TR39 security guideline for identifiers which &lt;a href=&#34;http://perl11.org/cperl/perl5252cdelta.html#Security&#34;&gt;cperl implements&lt;/a&gt;.
perl5 has no idea about that and is not willing to fix it, even if perlcc
prominently warns about that since 5.16.&lt;/p&gt;

&lt;p&gt;No &lt;a href=&#34;http://perl11.org/cperl/perl5240cdelta.html#Security&#34;&gt;Unicode confusables +UFFA0, +U3164&lt;/a&gt;. In deviation from Unicode 1.1
we treat the two HANGUL FILLER characters +UFFA0 and +U3164 not as
valid ID_Start and ID_Continue characters for perl identifiers.&lt;/p&gt;

&lt;h2 id=&#34;overlong-names&#34;&gt;overlong names&lt;/h2&gt;

&lt;p&gt;The &amp;ldquo;panic: hash key too long&amp;rdquo; error is now thrown with overlarge hash keys in every
&lt;code&gt;hv_common&lt;/code&gt; access and in Cpanel::JSON::XS.
perl5 still silently ignores those failures, and truncates the keys.&lt;/p&gt;

&lt;p&gt;Many more similar &amp;ldquo;panic: (file|keyword|mro|stash)? name too long&amp;rdquo; errors
were added to the parser and compiler to protect from overlong names
(&amp;gt; I32_MAX, 2147483647).&lt;/p&gt;

&lt;h2 id=&#34;insecure-taint-mode&#34;&gt;Insecure taint mode&lt;/h2&gt;

&lt;p&gt;perl5 has several known taint loopholes, see &lt;a href=&#34;http://perl11.org/cperl/perlsec.html#Taint-mode&#34;&gt;perlsec&lt;/a&gt;. cperl has them all fixed.&lt;/p&gt;

&lt;p&gt;Of course it is much faster to use tainted variables, as you don&amp;rsquo;t have to
check and sanitize every single variable, only external, tainted ones.&lt;/p&gt;

&lt;h1 id=&#34;minor-issues-from-perl540cdelta-http-perl11-org-cperl-perl5240cdelta-html-security&#34;&gt;Minor issues from &lt;a href=&#34;http://perl11.org/cperl/perl5240cdelta.html#Security&#34;&gt;perl540cdelta&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&#34;dynaloader-format-string-hardening&#34;&gt;DynaLoader format string hardening&lt;/h2&gt;

&lt;p&gt;Replace all &lt;code&gt;%&lt;/code&gt; characters in user-controlled library filenames, passed via
the system dl_error call verbatim to &lt;code&gt;printf&lt;/code&gt;, without any arguments on the stack,
which could lead to execution of arbitrary stack code. No CVE.
This affects all systems with dynamic loading where the attacker can cause a
dynamic loading error.&lt;/p&gt;

&lt;p&gt;CVSSv2 Severity: 7.2
(AV:L/AC:L/Au:N/C:C/I:C/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:H/IR:H/AR:ND)&lt;/p&gt;

&lt;h2 id=&#34;xsloader-relative-paths-with-eval-or-line&#34;&gt;XSLoader relative paths with eval or #line&lt;/h2&gt;

&lt;p&gt;Upstream XSLoader 0.22 (perl 5.26) fixed a minor security problem with
XSLoader within eval or with a #line directive, which can load a local
relative shared library, which is not in &lt;code&gt;@INC&lt;/code&gt;.
See &lt;a href=&#34;https://rt.cpan.org/Ticket/Display.html?id=115808&#34;&gt;https://rt.cpan.org/Ticket/Display.html?id=115808&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;cperl XSLoader was already protected against the eval case since 5.22,
when being rewritten in C. cperl-5.24.0 fixed now also ignoring a relative
filename in a &lt;code&gt;#line&lt;/code&gt; directive, when the relative path is not in &lt;code&gt;@INC&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;handle-method-calls-on-protected-stashes&#34;&gt;handle method calls on protected stashes&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/perl11/cperl/issues/171&#34;&gt;https://github.com/perl11/cperl/issues/171&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Known bug upstream, not fixed there. This problem appears more often
with cperl with its protected coretypes than upstream.&lt;/p&gt;

&lt;h2 id=&#34;fedora-do-not-crash-when-inserting-a-non-stash-into-a-stash&#34;&gt;fedora: Do not crash when inserting a non-stash into a stash&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128238&#34;&gt;Fedora Patch 37 RT#128238&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fedora-do-not-treat-as-a-stash&#34;&gt;fedora: Do not treat %: as a stash&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128238&#34;&gt;Fedora Patch36 RT#128238&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fedora-fix-precedence-in-hv-ename-delete&#34;&gt;fedora: Fix precedence in hv_ename_delete&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128086&#34;&gt;Fedora Patch35 RT#128086&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fedora-do-not-use-unitialized-memory-in-h-const-warnings&#34;&gt;fedora: Do not use unitialized memory in $h{\const} warnings&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128189&#34;&gt;Fedora Patch34 RT#128189&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fedora-do-not-mangle-errno-from-failed-socket-calls&#34;&gt;fedora: Do not mangle errno from failed socket calls&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128316&#34;&gt;Fedora Patch32 RT#128316&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fedora-backport-memory-leak-when-compiling-a-regular-expression-with-a-posix-class&#34;&gt;fedora: Backport memory leak when compiling a regular expression with a POSIX class&lt;/h2&gt;

&lt;p&gt;E.g. when C&lt;use re &#39;strict&#39;;&gt; is used.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://rt.perl.org/Public/Bug/Display.html?id=128313&#34;&gt;Fedora Patch31 RT#128313&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;suse-perl5-24-0-dif&#34;&gt;suse: perl5.24.0.dif&lt;/h2&gt;

&lt;p&gt;Many Configure and linux hints enhancements, esp for lib64,
probe fixes, gdbm and ODBM fixes, gnu readline integration with the debugger.
See &lt;a href=&#34;https://build.opensuse.org/package/show/devel:languages:perl/perl&#34;&gt;https://build.opensuse.org/package/show/devel:languages:perl/perl&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;suse-fix-regexp-backref-overflows&#34;&gt;suse: fix regexp backref overflows&lt;/h2&gt;

&lt;p&gt;With many backref groups (&amp;gt;I32)&lt;/p&gt;

&lt;h2 id=&#34;suse-perl-saverecontext-diff-rt-76538&#34;&gt;suse: perl-saverecontext.diff RT#76538&lt;/h2&gt;

&lt;p&gt;Handle get magic with globs in the regex compiler.
Correctly restore context, esp. when loading unicode swashes.
Reported at 5.12, patched for suse 5.14, still ignored with 5.24.&lt;/p&gt;

&lt;h1 id=&#34;minor-issues-from-perl541cdelta-http-perl11-org-cperl-perl5241cdelta-html-security&#34;&gt;Minor issues from &lt;a href=&#34;http://perl11.org/cperl/perl5241cdelta.html#Security&#34;&gt;perl541cdelta&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&#34;warn-on-metasploit-cve-2015-1592&#34;&gt;Warn on metasploit CVE-2015-1592&lt;/h2&gt;

&lt;p&gt;There are known and exploitable attack vectors published for years,
and there&amp;rsquo;s no effort to even detect or warn about it.&lt;/p&gt;

&lt;p&gt;cperl detects of the destructive attack against Movable-Type, the third
vector only, which tries to delete &lt;code&gt;mt-config.cgi&lt;/code&gt; was added to was
added to cperl &lt;code&gt;Storable&lt;/code&gt; 3.01c.&lt;/p&gt;

&lt;p&gt;Warns with &amp;ldquo;SECURITY: Movable-Type CVE-2015-1592 Storable metasploit attack&amp;rdquo;
but does not protect against it.&lt;/p&gt;

&lt;h2 id=&#34;warn-on-metasploit-reverse-shells&#34;&gt;Warn on metasploit reverse shells&lt;/h2&gt;

&lt;p&gt;cperl detects the metasploit payload unix/reverse_perl and some existing
variants.  This is just a dumb match at startup against existing
exploits in the wild, but not future variants.  Warns with
&amp;ldquo;SECURITY: metasploit reverse/bind shell payload&amp;rdquo;, but do not
protect against it. This warning is thrown even without C&amp;lt;-w&amp;gt;.&lt;/p&gt;

&lt;p&gt;Also detects the CVE-2012-1823 reverse/bind shell payload, which is
widely exploited too. The security warning is called
&amp;ldquo;SECURITY: CVE-2012-1823 reverse/bind shell payload&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;fixed-overwriting-the-hvhek-unshared-bit-in-the-hash-loop&#34;&gt;Fixed overwriting the HVhek_UNSHARED bit in the hash loop&lt;/h2&gt;

&lt;p&gt;Broken with v5.9&lt;/p&gt;

&lt;p&gt;This fixed &lt;code&gt;-DNODEFAULT_SHAREKEYS&lt;/code&gt;. In the default configuration
without &lt;code&gt;NODEFAULT_SHAREKEYS&lt;/code&gt; since 5.003_001 all hash keys are stored
twice, once in the hash and once again in &lt;code&gt;PL_strtab&lt;/code&gt;, the global
string table, with the benefit of faster hash loops and copies. Almost
all hashtables get the SHAREKEYS bit.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;-Accflags=-DNODEFAULT_SHAREKEYS&lt;/code&gt; simple scripts are 20-30%
faster.  &lt;a href=&#34;https://github.com/perl11/cperl/issues/201&#34;&gt;https://github.com/perl11/cperl/issues/201&lt;/a&gt; but practical
usage is dominated by copying hashes, which is faster with shared
keys.&lt;/p&gt;

&lt;h2 id=&#34;dfortify-inc&#34;&gt;-Dfortify_inc&lt;/h2&gt;

&lt;p&gt;A security problem.  Was in the very first cperl release 5.22.1,
because we detected it and developed the fixes. With full toolchain
support, in all modules. perl5 caught up 2 years later, 5.26.  But of
course they changed the established name to their own
&lt;code&gt;-Ddefault_inc_excludes_dot&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;perl4-package-seperator&#34;&gt;perl4 &amp;lsquo; package seperator&lt;/h2&gt;

&lt;p&gt;cperl deleted that, and fixed all issues.&lt;/p&gt;

&lt;h1 id=&#34;unicode-bugs&#34;&gt;unicode bugs&lt;/h1&gt;

&lt;p&gt;e.g range is broken in perl5, fixed in cperl 5.24.1c.
Apparently fixed with 5.26 finally.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $r = chr 255; utf8::upgrade $r; my $num = (&amp;quot;a&amp;quot; .. $r);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;utf8-padnames&#34;&gt;utf8 padnames&lt;/h2&gt;

&lt;p&gt;In perl5 all padnames are utf8 encoded by default. In cperl only those
who are utf8 encoded. &lt;a href=&#34;https://github.com/perl11/cperl/issues/208&#34;&gt;https://github.com/perl11/cperl/issues/208&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;compiler-toolchain-support&#34;&gt;compiler toolchain support&lt;/h2&gt;

&lt;p&gt;perl5 links with CC and ignores the linker LD, which disables advanced
llvm thin, lto and cfe support. e.g. clang-4 is produces 20% faster
code, and with cfe much safer code.&lt;/p&gt;

&lt;p&gt;perl5 is inable to produce reproducible builds. cperl does it by default.&lt;/p&gt;

&lt;h2 id=&#34;lexical-support&#34;&gt;lexical $_ support&lt;/h2&gt;

&lt;p&gt;perl5 was not able to find and fix the trivial bugs.
Their core features and modules rely on that, but they removed it.
esp. given/when, smartmatch, List::Utils.
cperl supports it.&lt;/p&gt;

&lt;h2 id=&#34;use-encoding&#34;&gt;use encoding&lt;/h2&gt;

&lt;p&gt;perl5 was not able to find and fix the trivial bugs. Many foreign devs
rely on that, but they removed it.  cperl supports it.&lt;/p&gt;

&lt;h2 id=&#34;pl-maxo&#34;&gt;PL_maxo&lt;/h2&gt;

&lt;p&gt;perl5 removed it, while it is necessary to track custom ops.
cperl supports it.&lt;/p&gt;

&lt;h2 id=&#34;for-qw&#34;&gt;for qw(&amp;hellip;)&lt;/h2&gt;

&lt;p&gt;perl5 removed support &lt;code&gt;for qw()&lt;/code&gt; with bogus justification. You need to write
&lt;code&gt;for (qw(..)) {}&lt;/code&gt;
The promised parser improvements never arrived.&lt;/p&gt;

&lt;p&gt;cperl allows &lt;code&gt;for qw(...)&lt;/code&gt; and supporting it is trivial.&lt;/p&gt;

&lt;h2 id=&#34;pmc-loading-and-reflection&#34;&gt;.pmc loading and reflection&lt;/h2&gt;

&lt;p&gt;perl5 removed timestamp checks for pugs with 5.8, a module doesn&amp;rsquo;t
know if it&amp;rsquo;s loaded from a &lt;code&gt;.pmc&lt;/code&gt;, and force loading a &lt;code&gt;.pm&lt;/code&gt; is not
possible.&lt;/p&gt;

&lt;p&gt;cperl fixed that for the upcoming JitCache support, which adds
expensively optimized subs for a package to a &lt;code&gt;.pmc&lt;/code&gt;. But only some, not
all subs.  So a &lt;code&gt;.pmc&lt;/code&gt; can never replace a full &lt;code&gt;.pm&lt;/code&gt;. So reflection and
loading &lt;code&gt;.pm&lt;/code&gt; needs to be enabled.&lt;/p&gt;

&lt;h1 id=&#34;core-modules&#34;&gt;Core modules&lt;/h1&gt;

&lt;h2 id=&#34;storable&#34;&gt;Storable&lt;/h2&gt;

&lt;p&gt;The CPAN version was never updated.  The core version suffers from
several severe core bugs, similar to the inability in core to support
huge &amp;gt;2GB data.&lt;/p&gt;

&lt;p&gt;cperl Storable fixes JD&amp;rsquo;s stack-overflow write (totally a CVE),
detects the known MetaSploit attack vector and supports large objects,
strings, hashed and arrays.&lt;/p&gt;

&lt;p&gt;There are also more stack-overflow attacks fixed in my CPAN version.&lt;/p&gt;

&lt;h2 id=&#34;yaml&#34;&gt;YAML&lt;/h2&gt;

&lt;p&gt;YAML is slow, incompatible with itself and insecure by default.&lt;/p&gt;

&lt;p&gt;e.g. Parse-CPAN-Meta security: cperl is 10x faster, can read its own files
and sets &lt;code&gt;$YAML::XS::DisableCode&lt;/code&gt;, &lt;code&gt;$YAML::XS::DisableBlessed&lt;/code&gt; while
parsing &lt;code&gt;META.yml&lt;/code&gt; or CPAN &lt;code&gt;.yml&lt;/code&gt; files.&lt;/p&gt;

&lt;p&gt;Very similar to Storable. At least with YAML the upstream maintainer is listening,
but he needs &amp;gt;1 year to merge my fixes, which is not acceptable. Nothing published
yet upstream. Needs to be &lt;a href=&#34;https://github.com/perl11/cperl/issues/198&#34;&gt;forked&lt;/a&gt; eventually.&lt;/p&gt;

&lt;h2 id=&#34;json-xs&#34;&gt;JSON::XS&lt;/h2&gt;

&lt;p&gt;Look at the relevant pod section in &lt;a href=&#34;http://search.cpan.org/dist/Cpanel-JSON-XS/XS.pm#SECURITY_CONSIDERATIONS&#34;&gt;Cpanel::JSON::XS&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;For the security bugs see on cperl:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -A20 &#39;=head1 Security&#39; pod/perl*cdelta.pod
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;comments-on-r-cperl-https-www-reddit-com-r-cperl-comments-5xof8j-worst-perl5-bugs&#34;&gt;Comments on &lt;a href=&#34;https://www.reddit.com/r/cperl/comments/5xof8j/worst_perl5_bugs/&#34;&gt;/r/cperl&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>cperl is not a religion</title>
      <link>http://perl11.org/blog/cperl-is-not-a-religion.html</link>
      <pubDate>Tue, 05 Jul 2016 12:35:00 +0200</pubDate>
      
      <guid>http://perl11.org/blog/cperl-is-not-a-religion.html</guid>
      <description>

&lt;h1 id=&#34;the-recent-perl5-management-problems-are-disturbing&#34;&gt;The recent perl5 management problems are disturbing&lt;/h1&gt;

&lt;p&gt;Criticizing the broken perl5 development process, the managers and esp. various technical problems is suddenly explicitly disallowed in the various perl5 forums by citing a new &amp;ldquo;bad faith&amp;rdquo; code of conduct rule. Mentioning incompetence of submitters is considered uncivil, and mentioning the marketing lies of the previous &amp;ldquo;pumpkin&amp;rdquo; (admin) is also considered uncivil. But lying, abusing the powers, and constant usage and even encouragement of foul language is interestingly not considered uncivil.&lt;/p&gt;

&lt;p&gt;cperl was initially created to overcome technical debt created by the current maintainership, who refuse to use a proper development process, refuse to take back wrong technical decisions which are blocking critical progress, and even discussing it. And mostly the complete lack of progress since 2001, but rather a disturbing series of grave technical mistakes and detoriation of the code base.&lt;/p&gt;

&lt;p&gt;We favor community-friendly democratic development policies as e.g. in perl6 over the usual old-style dictatorial model. That means the powerful (those with management and commit roles) are not allowed to abuse their powers, while the powerless users are allowed and need to have the abilities to criticise them and their code.&lt;/p&gt;

&lt;p&gt;In the old trust-based dictatorial model as e.g. in linux or perl5 the powerful call the not powerful abusive names (&amp;ldquo;asshole&amp;rdquo; or &amp;ldquo;jerk&amp;rdquo; is very common, or &amp;ldquo;trolls&amp;rdquo;), and are allowed to avoid discussions of features or problems by directly committing to master, rejecting tickets or selectively abuse their powers. This is forbidden in cperl.&lt;/p&gt;

&lt;p&gt;What want to give a forum to discuss future directions of the perl5 language, merging most of the perl6 features without breaking existing code.&lt;/p&gt;

&lt;p&gt;Such a discussion is historically not possible in the perl5 porters list, and now even not in the /r/perl subreddit anymore. Thanksfully cperl managed to overcome most of the stagnation of the last 10 years, within only one year of development. But most of the new features are only 90% finished.&lt;/p&gt;

&lt;p&gt;Interesting discussions would be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;how to fix p5p&lt;/li&gt;
&lt;li&gt;how to create a proper development process (hint: see what the others did)&lt;/li&gt;
&lt;li&gt;details of the new cperl features in development:
signatures, type system, inlining, symbol table, hashes, jit (tracing or method),
ops, class+method keywords, multi dispatch, native types, builtin ffi, native compiler
(unexec), &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://www.reddit.com/r/cperl/comments/4folk1/cperl_is_not_a_religion/&#34;&gt;Comments on /r/cperl/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>