<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>perl5 on perl11 blog</title>
    <link>https://perl11.github.io/blog/tags/perl5.html</link>
    <description>Recent content in perl5 on perl11 blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© 2016 Copyright Reini Urban</copyright>
    <lastBuildDate>Mon, 30 Jan 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://perl11.github.io/blog/tags/perl5/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Worst perl5 bugs</title>
      <link>https://perl11.github.io/blog/worst-perl5-bugs.html</link>
      <pubDate>Mon, 30 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://perl11.github.io/blog/worst-perl5-bugs.html</guid>
      <description>A small list of the worst perl5 bugs, all fixed in cperl DoS It&amp;rsquo;s trivial to DoS a perl5 system.
$a[9223372036854]=0; %a=(0..4294967296);  Examples for a 64bit system, but also trivial on 32bit. It creates a huge array or hash, which runs out of memory in the VMM subsystem which eventually kills the process. cperl dies with &amp;ldquo;Too many elements&amp;rdquo;, here even at compile-time.
No Hash Security Nothing is done against the root-cause of a hash flood denial of service attack with colliding keys, only some security theatre by using slower hash functions and slower collision resolution KEY_PERTURB_RANDOM.</description>
    </item>
    
  </channel>
</rss>